# QUES 

[尾递归优化（非严格模式）](https://wangdoc.com/es6/function.html#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0)

# ES6

## let 和 const

JS作用域：全局作用域（var声明，变量提升）、函数作用域、块级作用域（es6新增）

### let

**let关键字**：声明的变量只在当前代码块中生效（块级作用域）

- 可以重新赋值
- 不能在同一作用域重复声明
- 无变量提升 - 防止变量声明前使用变量

解决问题：

- **解决i丢失**的问题 - 不同于var**全局有效**，每次循环**let**都是重新声明的变量
- 内层变量可能会覆盖外层变量
- 替代匿名函数

**块级作用域**：内层作用域可以定义外层作用域的同名变量，ES6 的块级作用域**必须有大括号**

块级作用域**对函数**

- **允许在块级作用域之中声明函数**，行为同let变量（es5不允许）
- 函数提升到**全局作用域或函数作用域的头部**
- 函数声明还会提升到所在的**块级作用域的头部**

### const

- 只读常量，声明后不可改
- 必须给初始值
- 只在声明所在的块级作用域内有效
- 存在`TDZ`

**并不是保障值不变，而是变量指向内存地址不得改动**

普通类型：值保存在变量指向内存地址
引用类型：变量指向存放实际数据的指针

>对象冻结，应该使用`Object.freeze`方法，冻结后添加新属性不起作用，严格模式时还会报错

六种声明变量方法 ：`var、function、let、const、import、class`

### 暂时性死区

ES6 规定，区块中存在`let`和`const`命令，区块对`let const`声明的变量，形成了封闭作用域。声明之前就使用这些变量，就会报错，称为**暂时性死区**（temporal dead zone）

**本质**：进入作用域，变量就已经存在了，但是不可获取，只有声明变量的那一行代码之后（tdz结束），才可以获取和使用该变量。

```js
// #1
typeof x; // ReferenceError
let x; // tdz 结束
// #2
function bar(x = 2, y = x) {}
// #3 
let z=z
```

## 顶层对象

浏览器里面，顶层对象是`window`

浏览器和 Web Worker 里面，`self`也指向顶层对象

Node 里面，顶层对象是`global`

```js
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

ES2020引入`globalThis`作为顶层对象

## 解构赋值

**解构**：自动解析数组或对象中的值，并赋值给指定的变量

### 数组解构

**按序次**排列，解构不成功 ，undefined

```js
let [a, b, c] = [1, 2, 3]
let [foo, [[bar], baz]] = [1, [[2], 3]]
let [ , , third] = ["foo", "bar", "baz"]
let [x, y, ...z] = ['a'];
// y - undefined z -[]
let [a, [b], d] = [1, [2, 3], 4 , 5]; // 部分解构
let [foo = true] = []; // 指定默认值
let [x = f()] = [1]; // 惰性求值，f()不会执行
let [x = 1, y = x] = []; // 引用解构变量
```
等号右边为不可遍历结构，报错

ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值，就是判断是否严格等于`undefined`。(`null`与`undefined`不严格相等)

> 不可遍历结构：`1、false、NaN、undefined、null、{}`

### 对象解构

不按序次，但需与变量**同名**，解构不成功 ，undefined

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
const { log } = console;
let { first: f, last: l } = { first: 'hello', last: 'world' }; // 别名
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
// {x} 会被解析为代码块
// 正确的写法
let x;
({x} = {x: 1});
let {0 : first, [arr.length - 1] : last} = [1,2,3] // 解构数组，数组本质为特殊对象
```

### 字符串解构

```js
const [a, b, c, d, e] = 'hello';
let {length : len} = 'hello';
```

### 数值和布尔值解构

解构赋值时，等号右边的值**不是对象或数组**，则会**先转为对象**。`undefined`和`null`无法转为对象，所以解构赋值报错

数值和布尔值的包装对象都有`toString`属性

```js
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

### 函数参数解构

```js
function add([x, y]){
  // ...
}
add([1, 2]); // 3
// 含默认值
function move({x = 0, y = 0} = {}) {
  return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]

function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]

// 函数参数使用解构数组/对象，调用函数不传参数会报错
function fn([x, y, z]){
  	console.log(x, y, z);
}
fn(); //会报错
```

### 圆括号问题

以下**三种情况**不使用圆括号

#### 变量声明语句

```js
//  全部报错
let [(a)] = [1];
let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};
let { o: ({ p: p }) } = { o: { p: 2 } };
```

#### 函数参数

函数参数也属于变量声明

```js
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```

#### 赋值语句

```js
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
[({ p: a }), { x: c }] = [{}, {}];
```

#### [可以使用圆括号](https://wangdoc.com/es6/destructuring.html#%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%9C%86%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%83%85%E5%86%B5)

```js
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```

首先它们都是赋值语句，而不是声明语句；其次它们的**圆括号都不属于模式的一部分**。

第一行语句中，模式是取数组的第一个成员，跟圆括号无关；
第二行语句中，模式是`p`，而不是`d`；
第三行语句与第一行语句的性质一致。

### 应用

**（1）交换变量的值**

```js
[x, y] = [y, x];
```

（2）从函数返回多个值
（3）函数参数的定义
（4）提取 JSON 数据
（5）函数参数的默认值
**（6）遍历 Map 结构**

```js
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');
for (let [key, value] of map) {
  console.log(key + " is " + value);
}
```

（7）输入模块的指定方法

## 字符串扩展

### [字符的unicode](https://wangdoc.com/es6/string.html#%E5%AD%97%E7%AC%A6%E7%9A%84-unicode-%E8%A1%A8%E7%A4%BA%E6%B3%95)

### 字符串遍历接口

`for...of` - 可以识别 `0xFFFF`码点，传统`for`无法识别

### 字符串模板

JS单双引号字符串，均不解析变量，需要使用+号将变量拼接在字符串中

**字符串模板**（模板字面量）：允许使用反引号**``**来创建字符串

- 空格换行保留
- 变量写在 `${}`中，非字符串，如对象，调用`toString()`
- 可用Js表达式，能调用函数
- 可以嵌套
- 引用本身，写成函数

```js
let func = (name) => `Hello ${name}!`;
func('Jack') // "Hello Jack!" 引用本身
```

### [模板编译](https://wangdoc.com/es6/string.html#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91)

### 标签模板

模板字符串前面有一个标识名`tag`，它是一个函数。整个表达式的返回值，就是`tag`函数处理模板字符串后的返回值

```js
let a = 5;
let b = 10;

tag`Hello ${ a + b } world ${ a * b }`;

// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
```

```js
// 第一个参数为数组，模板字符串中没有被变量替换的部分
// 其他参数为替换变量
function tag(stringArr, value1, value2){
  // ...
  // stringArr - ['hello ',' world ','']
  // value1 - 15
  // value2 - 50
}
// 等同于
function tag(stringArr, ...values){
  // ...
}
```

[重要应用](https://wangdoc.com/es6/string.html#%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF)：

- 过滤HTML，防止用户输入恶意内容
-  多语言转换

### [模板字符串限制](https://wangdoc.com/es6/string.html#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%99%90%E5%88%B6)

## 字符串新增方法

**es5** - `String.fromCharCode()`：从Unicode码点返回字符串，不能识别大于0xFFFF的字符，`0x20BBF` 舍弃高位变为 `0x0BBF`

**es6** - `String.fromCodePoint()`：与`codePointAt()`相反，多个参数，合并为一个字符串

> `fromCodePoint`定义在String对象上，`codePointAt`定义在字符串对象上

**es6** - `String.raw()`：返回斜杠都被转义的字符串

**es5** - `charCodeAt()`：JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为`2`个字节。对于那些需要`4`个字节储存的字符（Unicode 码点大于`0xFFFF`的字符），JavaScript 会认为它们是两个字符。

**es6** - [`codePointAt()`](https://wangdoc.com/es6/string-methods.html#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Acodepointat)

**es6** - `normalize()`：将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化

**es5** - `indexOf()`：查找一个字符串是否在里一个字符串中

**es6** - 均返回**布尔值**

- `includes( string, number)`：**是否找到**参数字符串，从number开始
- `startsWith( string, number)`：参数字符串是否在**头部**，从number开始
- `endsWith( string, number)`：参数字符串是否在**尾部**，针对**前number**个数

**es6**

- `repeat()`：返回新字符串，原字符串重复n次
  - n为`小数`，取整
  - n为`负数`，`infinity`报错
  - n为`-1~0`，`NaN` ，均为0，返回空值
- `padStart()`：头部补全
  - 第一参数为最大长度，第二参数为补全字符串(默认为空格)
  - **大于等于**长度，返回原串
  - **补全长度 + 原串 > 最大长度**，截取补全字符串
- `padEnd()`：尾部补全，同上
- `trimStart()`：消除头部空格，返回新字符串
- `trimEnd()`：消除尾部空格

**es5**

- `replace()`

```js
'aabbcc'.replace('b', '_') // 替换第一个匹配
'aabbcc'.replace(/b/g, '_') // 替换所有匹配
```

**es6**

- `matchAll()`：**返回**一个正则表达式在当前字符串的**所有匹配**

- `replaceAll( searchValue, replacement)`

  - searchValue - 字符串* or **全局**正则表达式（带`g`修饰符，不带报错）
  - replacement - 字符串 or 函数，标识替换文本。
    - 字符串
      - `$&`：匹配的**子字符串**。
      - **$`**：匹配结果**前面**的文本。
      - `$'`：匹配结果**后面**的文本。
      - `$n`：匹配成功的第`n`组内容（**n从1**开始），前提是，第一个参数必须是正则表达式。
      - `$$`：指代美元符号`$`。
    - 函数

  ```js
  const str = '123abc456';
  const regex = /(\d+)([a-z]+)(\d+)/g;
  /*
  params #1 - 匹配内容
  params #2 - 捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）
  ...
  params #n-1 - 捕获内容在字符串位置
  parmas #n - 原字符串
  */
  function replacer(match, p1, p2, p3, offset, string) {
    return [p1, p2, p3].join(' - ');
  }
  str.replaceAll(regex, replacer)
  // 123 - abc - 456
  ```

## 正则扩展

### RegExp构造函数

**es5**

情况1 `(String , flag)`

- `new RegExp('xyz', 'i')`
- 等价于 `/xyz/i`

情况2 `(RegExp)`

- `new RegExp(/xyz/i)`
- 等价于 `/xyz/i`

**es6**：引入第三种情况，`(RegExp , flag)`

- `new RegExp(/abc/ig, 'i').flags` - 输出 `i`
- 等价于 `/abc/i`
- `flag`会覆盖原有修饰符

### 字符串正则方法

**es5**

`match()`、`replace()`、`search()`、`split()`

**es6**

将方法**关联到RegExp对象**

- `String.prototype.match` 调用 `RegExp.prototype[Symbol.match]`
- `String.prototype.replace` 调用 `RegExp.prototype[Symbol.replace]`
- `String.prototype.search` 调用 `RegExp.prototype[Symbol.search]`
- `String.prototype.split` 调用 `RegExp.prototype[Symbol.split]`

*ES2020* `String.prototype.matchAll()`：一次性取出所有匹配，返回的是一个遍历器（Iterator），而不是数组。

```js
const string = 'test1test2test3';
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) {
  console.log(match);
}
// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
```

### [u 修饰符](https://wangdoc.com/es6/regex.html#u-%E4%BF%AE%E9%A5%B0%E7%AC%A6)

`u`修饰符：用来正确处理大于`\uFFFF`的 Unicode 字符

```js
/^\uD83D/u.test('\uD83D\uDC2A') // false
/^\uD83D/.test('\uD83D\uDC2A') // true
```

### y 修饰符

“粘连”（sticky）修饰符，全局匹配，*后一次匹配都是从上一次匹配成功的下一个位置开始*。

**区别**：`g`确保**剩余**位置中匹配即可，`y`必须从**下一个**位置（*头部匹配*）开始

`lastIndex`属性：每次搜索开始位置

```js
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"] r1.lastIndex = 0
r2.exec(s) // ["aaa"] r2.lastIndex = 0

r1.exec(s) // ["aa"] r1.lastIndex = 3
r2.exec(s) // null r2.lastIndex = 3
```

> `y` 不会忽略非法字符

### [s 修饰符：dotAll 模式](https://wangdoc.com/es6/regex.html#s-%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Adotall-%E6%A8%A1%E5%BC%8F)

`s`修饰符：使得`.`可以匹配任意单个字符

```js
// es5
/foo[^]bar/.test('foo\nbar'); // true
// es2018
/foo.bar/s.test('foo\nbar'); // true
```

### RegExp.prototype

`RegExp.prototype.unicode`：表示是否设置了`u`修饰符

`RegExp.prototype.sticky` ：表示是否设置了`y`修饰符

`RegExp.prototype.flags`：会*返回*正则表达式的*修饰符*

`RegExp.prototype.dotAll`：返回一个布尔值，表示该正则表达式是否处在`dotAll`模式

### 断言

**先行断言** ：`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`

**先行否定断言**：`x`只有不在`y `前面才匹配，必须写成`/x(?!y)/`

```js
/\d+(?=%)/.exec('100% of US presidents have been male');  // ["100"]
/\d+(?!%)/.exec('that’s all 44 of them');                 // ["44"]
```

> 后行断言 *es2018* 引入

**后行断言**：`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`

**后行否定断言** ：`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`

```js
/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill');  // ["100"]
/(?<!\$)\d+/.exec('it’s is worth about €90');                // ["90"]
```

**后行断言组匹配**：先匹配`/(?<=y)x/`的`x`，然后再回到左边，匹配`y`的部分，**先右再左**

```js
// 匹配在(\d+)(\d+)后面的串，第2个(\d+)先贪婪匹配
/(?<=(\d+)(\d+))$/.exec('1053'); // ["", "1", "053"]
// 第1个(\d+)先贪婪匹配
/^(\d+)(\d+)$/.exec('1053'); // ["1053", "105", "3"]
```

*反斜杠引用*，**也**与通常的顺序**相反**

```js
/(?<=(o)d\1)r/.exec('hodor');  // null
/(?<=\1d(o))r/.exec('hodor');  // ["r", "o"]
```

### [Unicode 属性类](https://wangdoc.com/es6/regex.html#unicode-%E5%B1%9E%E6%80%A7%E7%B1%BB)

### 具名组匹配

```js
const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
```

> 具名组匹配 *es2018*

**具名组匹配**：`?<组名>`为每一组匹配指定一个名称，未匹配值为`undefined`

```js
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // "1999"
const month = matchObj.groups.month; // "12"
const day = matchObj.groups.day; // "31"
```

解构

```js
{groups: {year, month}} = RE_DATE.exec('1999-12-31');
```

`$<组名>`：引用组名

```js
let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;

// params#2 String
'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
// '02/01/2015'

// params#2 Function
'2015-01-02'.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 {year, month, day}
 ) => {
 let {day, month, year} = groups;
 return `${day}/${month}/${year}`;
});
```

`\k<组名>`：正则表达式内部引用，也可以用 `\1`进行捕获

```js
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
RE_TWICE.test('abc!abc!abc') // true
RE_TWICE.test('abc!abc!ab') // false
```

### [正则匹配索引](https://wangdoc.com/es6/regex.html#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95)

为`exec()`方法的返回结果加上`indices`属性，在这个属性上面可以拿到匹配的开始位置和结束位置。

## 数值扩展

二进制数（`0b，0B`），八进制数（`0o，0O`）

转十进制 `Number('0b111')`

### Number对象

目的：*减少全局方法，语言逐渐模块化*

`Number.isFinite()`：数值是否为有限的(`finite`)，即不是`Infinit,NaN`，参数类型不是`Number`直接返回`false`

`Number.isNaN()`：检测值**是否为NaN**，参数类型不是`NaN`，返回`false`

与全局方法区别：全局方法会先进行 **非数值转数值**，然后判断

```js
isFinite(25) // true
isFinite("25") // true
Number.isFinite(25) // true
Number.isFinite("25") // false

isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
Number.isNaN(1) // false
```

`Number.parseInt()`，`Number.parseFloat()`与全局方法行为一致。

`Number.isInteger()`：用来判断一个数值**是否为整数**，参数类型不是`Nuber`直接返回`false`

**整数和浮点数**采用**同样存储**方法，25和25.0视为同值

JavaScript 采用 IEEE 754 标准，数值存储为*64位双精度格式，*超过精度存在误判

- 数值精度最高：可以达到 *53 个二进制位* - 也就是*小数点后16个十进制位*（1 个隐藏位与 52 个有效位）
- 数值精度最低：`Number.MIN_VALUE`（5E-324）

```js
Number.isInteger(25) // true
Number.isInteger(25.0) // true
Number.isInteger(3.0000000000000002) // true
Number.isInteger(5E-325) // true
```

`Number.EPSILON`：极小常量，表示 1 与大于 1 的最小浮点数之间的差。误差小于此值，可以认为没有误差，实质为可以接受的最小误差范围

对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的`1.00..001`，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。

```js
function withinErrorMargin (left, right) {
  return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);
}

0.1 + 0.2 === 0.3 // false
withinErrorMargin(0.1 + 0.2, 0.3) // true

1.1 + 1.3 === 2.4 // false
withinErrorMargin(1.1 + 1.3, 2.4) // true
```

`Number.isSafeInteger()`：判断整数是**否在范围内**`（MIN_SAFE_INTEGER，MAX_SAFE_INTEGER）`

整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值

```js
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // 9007199254740991
Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // -9007199254740991
```

验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要**同时验证参与运算的每个值**。

```js
Number.isSafeInteger(9007199254740993)
// false
Number.isSafeInteger(990)
// true
Number.isSafeInteger(9007199254740993 - 990) // 超出了精度范围，以9007199254740992的形式储存
// true
9007199254740993 - 990
// 返回结果 9007199254740002
// 正确结果 9007199254740003
```

### Math对象

`Math.trunc()`：**去除一个数的小数部分**，返回整数部分。非数值，先转数值，空值和无法截取整数的值返回`NaN`

`Math.sign`方法用来判断一个数到底是**正数、负数、还是零**。对于非数值，会先将其转换为数值

```js
Math.sign(-5) // -1  负数
Math.sign(5) // +1  正数
Math.sign(0) // +0  0
Math.sign(-0) // -0  -0
Math.sign(NaN) // NaN 其他值
```

`Math.cbrt()`：计算一个数的**立方根**，对于非数值，会先将其转换为数值

`Math.clz32()`将参数**转为 32 位无符号整数的形式**，然后返回这个 32 位值里面**有多少个前导 0**。只考虑**整数部分**。对于非数值，会先将其转换为数值

```js
Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 << 1) // 30
Math.clz32(1 << 2) // 29
Math.clz32(1 << 29) // 2
```

`Math.imul()`：返回两个数以 **32 位带符号整数形式相乘**的结果

JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。对于那些很大的数的乘法，低位数值往往都是不精确的，`Math.imul`方法可以返回正确的低位数值。

```js
(0x7fffffff * 0x7fffffff)|0 // 0
Math.imul(0x7fffffff, 0x7fffffff) // 1
```

`Math.fround()`：返回一个数的**32位单精度浮点数**形式。对于 `NaN` 和 `Infinity`，此方法返回原值。对于非数值，会先将其转换为数值

作用：将*64位双精度浮点数*转为*32位单精度浮点数*。如果小数的*精度超过24个二进制位*，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）

`Math.hypot()`：返回所有参数的**平方和的平方根**。对于非数值，会先将其转换为数值。只要有一个参数无法转为数值，就会返回 NaN。

`Math.expm1(x)`：返回 `e^x - 1`，即`Math.exp(x) - 1`

`Math.log1p(x)`：返回`1 + x`的自然对数，即`Math.log(1 + x)`。如果`x`小于-1，返回`NaN`。

`Math.log10(x)`：返回以 10 为底的`x`的对数。如果`x`小于 0，则返回 `NaN`

`Math.log2(x)`返回以 2 为底的`x`的对数。如果`x`小于 0，则返回 `NaN`

`Math.sinh(x)` 返回`x`的双曲正弦（hyperbolic sine）

`Math.cosh(x)` 返回`x`的双曲余弦（hyperbolic cosine）

`Math.tanh(x)` 返回`x`的双曲正切（hyperbolic tangent）

`Math.asinh(x)` 返回`x`的反双曲正弦（inverse hyperbolic sine）

`Math.acosh(x)` 返回`x`的反双曲余弦（inverse hyperbolic cosine）

`Math.atanh(x)` 返回`x`的反双曲正切（inverse hyperbolic tangent）

### 指数运算符

ES2016  - 指数运算符（`**`），**从右向左结合**

```js
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
```

### BigInt 数据类型

`BigInt` ：**任何位数的`整数`**都可以精确表示，后缀必须为`n`

- BigInt ，普通整数是**两种值**
- `typeof`运算符对于 BigInt 类型的数据返回`bigint`
- 可以用 `-` 不能用 `+`

**BigInt对象**

`BigInt()`构造函数必须有参数，而且参数必须可以正常转为数值

```js
new BigInt() // TypeError
BigInt(undefined) //TypeError
BigInt(null) // TypeError
BigInt('123n') // SyntaxError
BigInt('abc') // SyntaxError
BigInt(1.5) // RangeError
BigInt('1.5') // SyntaxError
```

> 字符串`123n`无法解析成 Number 类型，所以报错

`BigInt.prototype.toString()`，`BigInt.prototype.valueOf()`，`BigInt.prototype.toLocaleString()`

`BigInt.asUintN(width, BigInt)`： 给定的 BigInt 转为 *0* 到 *2^width-1^* 之间对应的值。

`BigInt.asIntN(width, BigInt)`：给定的 BigInt 转为 *-2^width-1*^ 到 *2^width-1^-1* 之间对应的值。

`BigInt.parseInt(string[, radix])`：将一个字符串转换成指定进制的 BigInt

```js
// Number.parseInt() 与 BigInt.parseInt() 的对比
Number.parseInt('9007199254740993', 10)
// 9007199254740992
BigInt.parseInt('9007199254740993', 10)
// 9007199254740993n
```

**转换规则**

```js
Boolean(0n) // false
Boolean(1n) // true
Number(1n)  // 1
String(1n)  // "1"
!0n // true
!1n // false
```

**数学运算**

`+`、`-`、`*`、`**`：与 Number 类型的行为一致

`/`：**舍去小数部分**，返回一个整数

例外

- 不带符号的右移位运算符`>>>`
  - BigInt 总是带有符号的
- 一元的求正运算符`+`
  - BigInt **不能**与*普通数值*进行**混合运算**
  - 无论是返回 `BigInt` 或 `Number`都会丢失精度
- `|0`跟在一个数值的后面会返回一个32位整数
  - 因为不能混合运算，`1n | 0`会报错

`Math.sqrt`的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用`Number`方法转一下类型

```js
// 错误的写法
Math.sqrt(4n) // 报错

// 正确的写法
Math.sqrt(Number(4n)) // 2
```

**其他运算**

BigInt 对应的**布尔值**，与 Number 类型一致，即`0n`会转为`false`，其他值转为`true`。

**比较运算符**（比如`>`）和相等运算符（`==`）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。

```js
0n < 1 // true
0n < true // true
0n == 0 // true
0n == false // true
0n === 0 // false
```

BigInt 与**字符串**混合运算时，会先转为字符串，再进行运算。

```js
'' + 123n // "123"
```

## 函数扩展

### 参数默认值

ES6：定义函数可以指定默认值。

- 参数变量是默认声明，不可用`let`或`const`再次声明
- 函数不能有同名参数
- 参数为惰性求值，每次都要重新计算
- 传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}
foo() // 100
x = 100;
foo() // 101
```

#### 参数默认值与解构

下面写法：不能省略第二个参数，对象中的属性有默认值，但是对象本身没有

```js
function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}
// 正确写法
// { body = '', method = 'GET', headers = {} } = {}
```

```js
// 解构的值赋予默认值
{x = 0, y = 0} = {}
{} - 0,0
// 解构的对象赋予默认值
{x, y} = { x: 0, y: 0 }
{} - undefined,undefined
```

#### 参数默认值位置

定义了默认值的参数，应该是**尾参数**。非尾参数，用`undefined`占位

```js
function f(x=1,y){}
f() // 1 undefined
f(,1) // 报错
f(undefined,1) // 1 1
f(2,1) // 2 1
```

#### 函数length属性

函数的`length`属性，将返回**没有指定默认值的参数个数**。

`rest`参数也不会计入length。

默认值参数不是尾参数，length不会计入后面的参数

```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2

(function(...args) {}).length // 0

(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

#### 作用域

一旦*设置了参数的默认值*，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。

```js
// y = x 形成 单独作用域
// 实际执行 let y = x

function f( y = x ){
    let x = 0;
    console.log(x,y)
}
f(1)
```

```js
function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar() // ReferenceError: foo is not defined
```

`y`默认值为匿名函数，其中`x`指向同作用域第一个参数`x`。

`foo`函数内部变量 x 是与 `foo` 参数变量 `x` 不同

执行 `y()` 只会影响*参数变量*，*外部变量*和*内部变量*都不会改变

```js
var x = 1;
function foo(x, y = function() { x = 2; }) {
  // x - undefined
  var x = 3;
  // x - 3
  y();
  // x - 3
  console.log(x);
}
foo() // 3
// x - 1
```

与上面不同的是，*没有内部变量*，此时`x=3`中的`x`为参数变量。

```js
var x = 1;
function foo(x, y = function() { x = 2; }) {
  // x - undefined
  x = 3;
  // x - 3
  y();
  // x - 2
  console.log(x);
}

foo() // 2
x // x - 1
```

参数默认值在运行时执行，利用参数默认值，让不填参数就报错

```js
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
```

### rest参数

ES6中，引入rest参数 （`...变量名`），用于获取多余参数，代替`arguments`

`arguments`为类似数组对象，需转换为数组（ `Array.prototype.slice.call`）。

`rest`参数为真正数组，无需转换

```js
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```

rest参数后不能有其他参数，即*rest参数为最后一个参数*

```js
function f(a, ...b, c) {} // 报错
```

函数`length`属性，不包括rest参数

```js
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

### 严格模式

*ES5*，内部可以设定严格模式

*ES2016*，函数参数使用默认值，解构赋值，扩展运算符后，不能显示定义为 严格模式

> 严格模式适用于 函数内部和函数参数。
>
> 原因：*只有在函数体内才能知道是否以严格模式执行，但参数执行先于函数内部*

```js
// 报错
function doSomething(value = 070) {
  'use strict';
  return value;
}
```

**报错分析**：严格模式下不能使用前缀 `0`表示八进制。

首先`value=070`，进入函数内部，发现严格模式执行，所以报错。

**解决方案**

全局性严格模式

```js
'use strict';

function doSomething(value = 070) {
  return value;
}
```

包裹在无参数的立即执行函数里面

```js
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
```

### name属性

- *匿名函数*：赋值给变量，函数`name`属性为空字符串（ES5），实际函数名（ES6）

- *具名函数*：赋值给变量，`name`属性为函数名（ES5，ES6相同）

- *对象方法*：

  - 使用了取值函数（`getter`）和存值函数（`setter`），函数名前加 `get` 和 `set`

  ```js
  const obj = {
    get foo() {},
    set foo(x) {}
  };
  
  obj.foo.name
  // TypeError: Cannot read property 'name' of undefined
  
  const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
  
  descriptor.get.name // "get foo"
  descriptor.set.name // "set foo"
  ```

  - 对象方法是一个 Symbol 值，那么`name`属性返回的是这个 Symbol 值的描述

  ```js
  const key1 = Symbol('description');
  const key2 = Symbol();
  let obj = {
    [key1]() {},
    [key2]() {},
  };
  obj[key1].name // "[description]"
  obj[key2].name // ""
  ```

- *构造函数*：返回函数实例，`name`属性为`anonymous`

```js
(new Function).name // "anonymous"
```

- *bind*：返回函数，`name`属性加上`bound`前缀

```js
function foo() {};
foo.bind({}).name // "bound foo"
(function(){}).bind({}).name // "bound "
```

### 箭头函数

`ES6`：箭头（`=>`）定义函数

#### 基础用法

*函数参数*：**不需要参数**或**多个**参数，圆括号代表参数部分

```js
() => 5;
(x, y) => x + y;
```

*代码块*：**多于一条**语句，对象外加`{}`,并且 `return` 语句返回

```js
(num1, num2) => { return num1 + num2; }
```

*返回对象*：因为大括号解析为代码块，箭头函数直接返回一个对象时，外层加上`()`

```js
() => { id: id, name: "Temp" } // 报错
() => ({ id: id, name: "Temp" }) // 正确
```

*特殊情况*：`{}`被解析为代码块，函数内部执行 `a:1`，无返回值

```js
let foo = () => { a: 1 };
foo() // undefined
```

*无需返回值*：单行语句，且**不需要返回值**，采用以下写法

```js
let fn = () => void doesNotReturn();
```

*解构、rest参数*

```js
({ first, last }) => first + ' ' + last;
(...nums) => nums
```

#### 注意点

- 函数内`this`对象，**定义时所在对象，而不是使用者所在对象**（`this`指向**固定化**）,有利于函数封装
- 因为箭头函数没有自己的`this`，导致内部`this`指向外部`this`。并且使用`call()、apply()、bind()`改变`this`指向
- **不可做构造函数**，不可以使用`new`命令，否则会抛出一个错误，没有prototype
- 不可使用 `arguments`对象（不存在），使用`rest`参数代替
- 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数
- `super、new.target` 在箭头函数中也是不存在，指向外层变量
- `typeof` 判断箭头函数 结果为`function`
- `instanceof` 判断是否`Function`实例 结果为true

```js
function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数 this -> timer
  setInterval(() => this.s1++, 1000);
  // 普通函数 this -> window
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
```

下面代码有几个`this`？

```js
function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
```

只有一个`this`，即`foo`的`this`

#### 不适用场合

以下两种方法应使用传统写法，而非箭头对象

##### 定义对象的方法

对象中使用箭头函数，*函数会指向对象所在作用域*，此处是`window`，普通函数指向`obj`

```js
globalThis.s = 21; // globalThis 此处 -> window
const obj = {
  s: 42,
  m: () => console.log(this.s)
};

obj.m() // 21
```

##### 动态this

箭头函数指向`window`，普通函数指向`被点击的按钮对象`

```js
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

#### 嵌套箭头函数

部署管道机制（pipeline）

```js
const pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);
```

**[?]**  λ 演算

```js
// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f => (x => f(v => x(x)(v)))
               (x => f(v => x(x)(v)));
```

#### 尾调用优化

##### 尾调用

**尾调用（Tail Call**）：指某个函数的最后一步是调用另一个函数

```js
function f(x){
  return g(x);
}
```

尾调用不一定出现在函数尾部，只要是最后一步操作

```js
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

**非尾调用**

- 调用函数后，还有赋值操作
- 调用函数附带其他操作

```js
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
  // return undefined
}
```

##### 尾调用优化

函数调用会在内存形成*调用记录*，又称*调用帧*，保存调用位置和内部变量信息。

>如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）

尾调用为*函数最后一步*操作，所以*不需要保留外层函数的调用帧*，因为调用位置、内部变量等信息都不会再用到。

**尾调用优化**（Tail call optimization），*保留内层函数的调用帧*。如果所有函数都是尾调用，每次执行时，调用帧只有一项，这将*大大节省内存*。

> 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

#### 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

*递归非常耗费内存*，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）

尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

##### 非尾递归

```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
```

##### 尾递归

```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

##### 递归函数改写

所有用到的*内部变量*改写成*函数的参数*。

缺点：不太直观，计算5阶乘，为何传1

```js
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

tailFactorial(5 , 1) // 120
```

*方案1*：外部提供正常函数

```js
function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
```

**柯里化**：多参数函数转为单参数函数

```js
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

const factorial = currying(tailFactorial, 1);
factorial(5) // 120
```

*方案2*：ES6默认值

```js
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

**尾调用优化之只在严格模式下有用**

因为正常模式下，存在`func.arugments`和`func.caller`，尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。

- `func.arguments`：返回调用时函数的参数。
- `func.caller`：返回调用当前函数的那个函数。

##### ？尾递归优化实现

尾递归优化只在严格模式下生效，正常模式下，或者那些不支持该功能的环境中。通过采用*“循环”换掉“递归”*。实现尾递归优化，

**蹦床函数（trampoline）**可以将递归执行转为循环执行

这里是*返回一个函数，然后执行函数*，并非函数中调用函数，避免了递归执行。

```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
```

#### 函数参数的尾逗号

*ES2017* 允许函数的最后一个参数有尾逗号（trailing comma）

#### Function

`Function.prototype.toString()`：返回函数代码本身，以前会省略注释和空格。*ES2019*后不会

```js
function /* foo comment */ foo () {}
foo.toString()
// "function /* foo comment */ foo () {}"
```

#### catch 命令的参数省略

`catch`代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。

*ES2019* 做出了改变，允许`catch`语句省略参数。

## 数组扩展

### 扩展运算符

**扩展运算符**（spread）是三个点（`...`），将一*个数组转为用逗号分隔*的参数序列。`rest`参数逆运算

- 与函数参数结合
- 放置表达式：`[...(x > 0 ? ['a'] : [])]`
- 空数组：不产生效果
- 函数调用时，扩展运算符才能放圆括号中

```js
(...[1, 2])
// Uncaught SyntaxError: Unexpected number
console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number
console.log(...[1, 2])
// 1 2
```

#### 替代apply方法

```js
// ES5
Math.max.apply(null, [14, 3, 77])
// ES6
Math.max(...[14, 3, 77])

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
```

#### 扩展运算符应用

**复制数组**：直接赋值（`arr1=arr2`），只是复制了指向底层数据结构的指针（**浅拷贝**）

以下代码`a1`会返回原数组的克隆，修改`a2`不影响`a1`。

```js
// ES5
const a1 = [1, 2];
const a2 = a1.concat();
// ES6
// 写法1
const a2 = [...a1];
// 写法2
const [...a2] = a1;

a2[0] = 2;
a1 // [1, 2]
```

**合并数组**：浅拷贝

```js
const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
```

**解构赋值**：与解构赋值结合起来，用于生成数组。

扩展运算符用于数组赋值，只能放在参数的*最后一位*

```js
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错
```

**字符串**：将字符串转为真正的数组。且能够正确识别四个字节的`Unicode`

JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。

```js
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
```

涉及到操作四个字节的 Unicode 字符的函数，最好都用扩展运算符改写。

```js
function length(str) {
  return [...str].length;
}
```

**iterator接口对象**：任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为**真正的数组**。

**Map 和 Set 结构，Generator 函数**：扩展运算符内部调用的是数据结构的 Iterator 接口，只要具有 Iterator 接口的对象，都可以使用扩展运算符。

```js
// Map
let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
// Generator
const go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]
```

没有 Iterator 接口的对象，使用扩展运算符，将会报错。

```js
const obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
```

### Array.form()

`Array.from`：将两类对象转为真正的数组

- 类似数组的对象（array-like object）
- 可遍历（iterable）的对象（Set 和 Map）

>如果**参数为数组**，将会**返回**一样的**新数组**

```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
// ES5
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
// ES6
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
// NodeList
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {})
```

**类数组对象**：必须有`length`属性。任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。因为扩展运算符调用的是**遍历器接口**（`Symbol.iterator`），如果没有部署这个接口，就无法转换。

```js
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```

**等效写法**

```js
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();
```

**第二参数**

```js
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);
```

**重复数据**

```js
Array.from({ length: 2 }, () => 'jack') // ['jack', 'jack']
```

**处理各种** Unicode **字符**，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符

```js
function countSymbols(string) {
  return Array.from(string).length;
}
```

### Array.of()

`Array.of()`：将一组值，转换为数组。

- 弥补数组构造函数`Array()`的不足，参数不同，行为有差异
- 参数不少于2个才会组成新数组

```js
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]

Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```

**等效写法**

```js
function ArrayOf(){
  return [].slice.call(arguments);
}
```

### 数组实例

#### copyWithin()

`copyWithin(target,start,end)`：在数组内部，将**指定位置**的成员**复制到其他位置**（会覆盖原有成员），然后返回当前数组。（**会改变当前数组**）

- `target`（**必需**）：从该位置*开始替换*数据。如果为负值，表示倒数。
- `start`（可选）：从该位置*开始读取*数据，默认为 0。如果为负值，表示从末尾开始计算。
- `end`（可选）：到该位置前*停止读取*数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

>三个参数都应该是数值，如果不是，会自动转为数值。

```js
// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// s
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// 3 4 5 -> 0
// Int32Array [3, 4, 5, 4, 5]

// 替换写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
```

#### find() ，findIndex()

`find(callback)`：用于找出**第一个符合**条件的**数组成员**。

- 执行回调，找出第一个返回`true`

- 都不符合 返回 `undefined`

- `callback (value, index, arr)`

`findIndex(callback)`：返回第一个符合条件的**数组成员的位置**

- 都不符合，返回 `-1`

**第二参数**：来绑定回调函数的`this`对象

```js
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

**NaN**

两种方法都能发现NaN，但是**indexof不能**

```js
[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

#### fill()

`fill`：使用给定值，填充一个数组。（**浅拷贝**）

- `value`（必）：填充数据，默认填充`undefined`
- `startIndex`（可）：起始位置
- `endIndex`（可）：结束位置

####   entries()，keys() ，values()

`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象，可以用`for...of`循环进行遍历

区别：`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

```js
for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

不使用`for...of`，手动调用遍历器`next`方法代替

```js
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
entries.next().value; // [0, 'a']
entries.next().value; // [1, 'b']
entries.next().value; // [2, 'c']
```

#### includes()

`includes(value, startIndex)`：返回一个布尔值，表示某个数组是否**包含给定的值** (**ES2016**)

- `value`
- `startIndex`：起始位置，默认为0
- 弥补了`indexof`不足

`indexof()`缺点

- 找到参数值的第一个出现位置，所以要去比较是否不等于`-1`
- 内部使用严格相等运算符（`===`）进行判断，这会导致对`NaN`的误判

**兼容写法**

```js
const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false
```

`Map`和`Set`中`has`方法和 `includes`区别

- `Map` 结构的`has`方法，是用来**查找键名**的
- `Set` 结构的`has`方法，是用来**查找值**的

#### flat()，flatMap()

`flat()`：将**嵌套**的数组变成**一维**的数组。

- 返回一个**新**数组
- 默认拉平一层
- 会跳过空位

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]
[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]
[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
```

`flatMap()`：**先**对原数组的每个成员执行一个函数`map()`，**然后**返回值组成的数组执行`flat()`方法

-  `map+flat`
- 默认展开一层
- 回调函数参数
  - `currentValue`：当前数组成员
  - `index`：数组位置
  - `array`：原数组
- 第二参数：绑定遍历函数里面的`this`

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

```js
arr.flatMap(function callback(currentValue[, index[, array]]) {
  // ...
}[, thisArg])
```

### 数组空位

**数组的空位**：数组的某一个位置没有任何值

空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。

空位是没有任何值，`in`运算符可以说明这一点

```js
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
```

**ES5对空位处理**

- `forEach()`, `filter()`, `reduce()`, `every()` 、`some()`：都会跳过空位。
- `map()`：跳过空位，但会保留这个值
- `join()`、`toString()`：将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。

```js
// forEach方法
[,'a'].forEach((x,i) => console.log(i)); // 1

// filter方法
['a',,'b'].filter(x => true) // ['a','b']

// every方法
[,'a'].every(x => x==='a') // true

// reduce方法
[1,,2].reduce((x,y) => x+y) // 3

// some方法
[,'a'].some(x => x !== 'a') // false

// map方法
[,'a'].map(x => 1) // [,1]

// join方法
[,'a',undefined,null].join('#') // "#a##"

// toString方法
[,'a',undefined,null].toString() // ",a,,"
```

**ES6空位处理**：将空位转为`undefined`

- `Array.from`：将数组的空位，转为`undefined`
- 扩展运算符（`...`）：将空位转为`undefined`
- `copyWithin()`：连空位一起拷贝
- `fill()`：将空位视为正常的数组位置
- `for...of`：会遍历空位
- `entries()`、`keys()`、`values()`、`find()`、`findIndex()`：将空位处理成`undefined`。

### [sort() 的排序稳定性](https://wangdoc.com/es6/array.html#arrayprototypesort-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7)

**排序稳定性**（`stable sorting`）：排序**关键字相同**的项目，**排序前后的顺序不变**。

- **插入排序、合并排序、冒泡排序**等都是稳定的
- **堆排序、快速排序**等是不稳定的。
- 不稳定排序缺点：多重排序时可能会产生问题。
- 假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。

> *ES2019*明确规定，`Array.prototype.sort()`的默认排序算法必须稳定。

## 对象扩展

### 简洁表示

**属性简写**：属性名和变量名一致时

```js
// ES5
{x: x, y: y}
// ES6
{x, y}
```

**方法简写**：去掉`:`，省略`function`

```js
// ES5
method: function() {
  return "Hello!";
}
// ES6
method() {
  return "Hello!";
}
```

> 简写对象方法*不能作构造函数*

**tip**：对象的简洁表示法，每组键值对会打印对象名，更清晰

```js
let user = {name: 'test'};
let foo = {bar: 'baz'};

console.log(user, foo)
// {name: "test"} {bar: "baz"}
console.log({user, foo})
// {user: {name: "test"}, foo: {bar: "baz"}}
```

### 属性名表达式

**属性名**

- ES5 只能用 **标识符**定义属性
- ES6 允许使用**表达式**定义属性，方法名同样适用

```js
// ES5
obj.foo = true;
obj = {
  foo: true,
  abc: 123
};
// ES6
obj['a' + 'bc'] = 123;
obj = {
  [propKey]: true,
  ['a' + 'bc']: 123,
  ['h' + 'ello']() {
    return 'hi';
  }
};
```

表达式与简洁表示*不能同时使用*

```js
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

属性名表达式为对象，默认转为 `[object Object]`

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

`keyB` 会覆盖 `keyA`

### 属性枚举性和遍历

#### 可枚举性

对象的每个属性都有一个描述对象（`Descriptor`），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`：可以获取该属性的描述对象。

```js
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,  // 可枚举性
//    configurable: true
//  }
```

以下操作会忽略`enumerable`为`false`的属性，让某些属性可以*规避掉遍历*。

> `toString`和`length`属性的`enumerable`都是`false`，因此`for...in`不会遍历到这两个继承自原型的属性。

- `for...in`：只遍历对象*自身*的和*继承*的可枚举的属性
- `Object.keys()`：返回对象*自身*的所有可枚举的属性的键名
- `JSON.stringify()`：只串行化对象*自身*的可枚举的属性
- `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性

> 引入继承的属性会让问题复杂化，大多时候用 `Object.keys()`代替 `for...in`

ES6规定，所有 Class 的原型的方法都是不可枚举的

```js
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false
```

#### 遍历（5种）

- `for...in`：循环遍历对象*自身和继承可枚举属性*
  - 自身、继承、可枚举
  - 不含Symbol属性
- `Object.keys`：返回一个数组，包括对象*自身可枚举属性的键名*
  - 自身、可枚举
  - 不含继承、不含Symbol属性
- `Object.getOwnPropertyNames`：返回一个数组，包含对象自身的*所有属性的键名*
  - 自身、不管枚举性
  - 不含Symbol属性
- `Object.getOwnPropertySymbols`：返回一个数组，包含对象*自身的所有 Symbol 属性*的键名
  - 自身、Symbol属性
- `Reflect.ownKeys`：返回一个数组，包含对象*自身*的所有键名
  - 自身、不管枚举性、Symbol属性
  - 不含继承

**遍历次序**

- 首先遍历所有**数值**键，按照**数值升序**排列
- 其次遍历所有**字符串**键，按照加入**时间升序**排列
- 最后遍历所有**Symbol**键，按照加入**时间升序**排列

### super关键字

`this`：总是指向函数所在的**当前对象**

*ES6* `super`：指向当前对象的**原型对象**

```js
const proto = {
  foo: 'hello',
  print(){
      console.log(this.foo)
  }
};

const obj = {
  foo: 'world',
  find() {
      console.log(super.foo)
  },
  print(){
      super.print()
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // "hello"
obj.print() // "world"
```

- `super.print()`指向`proto`中`print()`，但是绑定的`this`还是`obj`
- JavaScript 引擎内部`super.foo`等同于
  - `Object.getPrototypeOf(this).foo`（属性）
  - `Object.getPrototypeOf(this).foo.call(this)`（方法）。

**原型对象只能用在对象方法中**

以下三种写法`super`都未用在对象方法中，目前只有*简写法可以定义对象方法*

```js
// 报错 用在属性中
const obj = {
  foo: super.foo
}

// 报错 用在函数中，赋值给foo属性
const obj = {
  foo: () => super.foo
}

// 报错 ...
const obj = {
  foo: function () {
    return super.foo
  }
}
```

### 解构赋值

**对象的解构赋值**：将目标对象自身所有可遍历、但尚未被读取的属性，分配到指定的对象上面

- *等号右边是对象*，`null`或`undefined`会报错
- *解构赋值必须是最后一个参数*，反之报错
- *解构赋值为浅拷贝*
- 扩展运算符解构赋值，*不能复制继承自原型对象属性*

```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };// 局部解构
// 1
let { ...z } = null; // 运行时错误
let { ...z } = undefined; // 运行时错误
// 2
let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误
// 4
const o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...newObj } = o;
let { y, z } = newObj;
x // 1
y // undefined
z // 3
```

- `x`为*解构赋值*，可以读取继承属性
- `y`和`z`为*扩展运算符解构赋值*，`y`取不到，`z`能取到

### 扩展运算符

**对象的扩展运算符**（`...`）：取出参数对象的所有可遍历属性，拷贝到当前对象之中。

- 数组是特殊对象，*扩展运算符可用于数组*
- *空对象，无效果*
- 不是对象*自动转为对象*
- *字符串*，自动转为*类似数组对象*
- 等效于 `Object.assign()`

```js
// 等同于 {...Object(1)}
{...1} // {}
{...true} // {}
{...undefined} // {}
{...null} // {}

{...'hello'}
// {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}

// 合并对象
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

以上*只拷贝了对象实例属性*，以下三种拷贝完整对象

```js
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

> `__proto__`属性在非浏览器的环境不一定部署，推荐写法二、三

用户自定义的属性，*放在扩展运算符后面*，则扩展运算符内部的*同名属性会被覆盖掉*。

```js
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
```

**应用**：*修改部分*属性

```js
let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};
```

自定义属性*放在扩展运算符前面*，就变成了*设置新对象的默认属性值*。

```js
let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
```

与数组相同，后面*可跟表达式*

会执行取值函数`get`

```js
let a = {
  get x() {
    throw new Error('not throw yet');
  }
}

let aWithXGetter = { ...a }; // 报错
```

### 链判断运算符

读取对象内部的某个属性，需要判断一下该对象是否存在。

**三元运算符**`?:`也常用于判断对象是否存在。

```js
const fooValue = fooInput ? fooInput.value : undefined
```

*ES2020* **链判断运算符**`?.`：判断是否为`null`或`undefined`，如果是，返回`undefined`

```js
// 属性
const fooValue = fooInput?.value
// 动态属性
obj?.[expr]
// 函数、方法调用
func?.(...args)
```

**短路机制**：不满足条件，不向下执行。如果左侧为真，++x不执行

```js
a?.[++x]
// 等同于
a == null ? undefined : a[++x]
```

**delete运算符**

```js
delete a?.b
// 等同于
a == null ? undefined : delete a.b
```

**括号影响**：属性链有圆括号，链判断运算符*对圆括号外部没有影响*

```js
(a?.b).c
// 等价于
(a == null ? undefined : a.b).c
```

**报错场合**：以下均不合法

```js
// 构造函数
new a?.()
new a?.b()

// 右侧有模板字符串
a?.`{b}`
a?.b`{c}`

// 左侧是 super
super?.()
super?.foo

// 左侧用于赋值运算符
a?.b = c
```

**右侧不得为十进制**：保证兼容以前的代码，允许`foo?.3:0`被解析成`foo ? .3 : 0`

### Null判断运算符

同过 `||` 指定默认值，本意是 值为`null`或`undefined`，默认值生效，实际上`false`或`0`也会生效

```js
const default = val || 'world'
```

*ES2020*  **Null 判断运算符**`??`：类似`||`，但运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

`??`有一个运算优先级问题，它与`&&`和`||`的优先级孰高孰低。现在的规则是，*如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。*

```js
lhs && middle ?? rhs // 报错

(lhs && middle) ?? rhs;
lhs && (middle ?? rhs);
```

## 对象的新增方法

### Object.is()

ES5比较值，`==`或`===`

- `==`：会自动转换数据类型
- `===`：`NaN`不等于自身，`+0`等于`-0`

`Object.is()` *ES6*：比较两个值是否严格相等。与`===`基本一致

```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

ES5部署`Object.is()`

```js
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
```

### Object.assign()

`Object.assign()`：将源*自身*对象所有*可枚举*属性（含*Symbol*），复制到目标对象

- 第一参数：目标对象
  - 只有一个参数，直接返回
  - 不是对象转换为对象，`undefined`和 `null`无法转为对象，报错
- 后面参数：源对象
  - 不是对象转换为对象，`undefined`和 `null`会跳过
  - 数值、字符串、布尔值，*字符串会以数组形式拷贝*，其他值忽略（只有字符串转为对象，产生可枚举属性）
- **同名参数**，源对象覆盖目标对象，后面源对象覆盖前面源对象
- **浅拷贝**
- 处理 **数组**，数组会视为对象
- **取值函数**：先求值再处理

### getOwnPropertyDescriptors()

*ES5*`Object.getOwnPropertyDescriptor()`：返回**某个**对象属性的描述对象（descriptor）。

*ES2017*`Object.getOwnPropertyDescriptors()`：返回指定对象**所有自身**属性的描述对象

解决`Object.assign()`无法正确拷贝 `get` 和 `set` 属性

```js
const source = {
  set foo(value) {
    console.log(value);
  }
};
const target1 = {};
Object.assign(target1, source);
Object.getOwnPropertyDescriptor(target1, 'foo')
// ...
const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
```

配合`Object.create()`方法，将对象属性克隆到新对象（**浅拷贝**）

```js
const clone = Object.create(Object.getPrototypeOf(obj),
Object.getOwnPropertyDescriptors(obj));
```

实现一个对象**继承**另一个对象

```js
const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
```

实现**混入**模式

```js
let mix = (object) => ({
  with: (...mixins) => mixins.reduce(
    (c, mixin) => Object.create(
      c, Object.getOwnPropertyDescriptors(mixin)
    ), object)
});

// multiple mixins example
let a = {a: 'a'};
let b = {b: 'b'};
let c = {c: 'c'};
let d = mix(c).with(a, b);

d.c // "c"
d.b // "b"
d.a // "a"
```

### \_\_proto__

`__proto__`：读取或设置当前对象原型对象，实际是调用`Object.prototype.__proto__`

**实现如下**

```js
Object.defineProperty(Object.prototype, '__proto__', {
  get() {
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  },
  set(proto) {
    if (this === undefined || this === null) {
      throw new TypeError();
    }
    if (!isObject(this)) {
      return undefined;
    }
    if (!isObject(proto)) {
      return undefined;
    }
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) {
      throw new TypeError();
    }
  },
});

function isObject(value) {
  return Object(value) === value;
}
```

### setPrototypeOf()

与`__proto__`相同，*设置*对象原型对象（*推荐*）

```js
Object.setPrototypeOf(object, prototype)
// 等效
function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```

第一参数*不是对象*，会自动转对象，此函数返回值为第一参数，所以操作无效

第一参数为 `undefined`，`null`会报错

```js
Object.setPrototypeOf('foo', {}) === 'foo' // true
```

### getPrototypeOf()

*读取*一个对象的原型对象

不是对象，转对象，`undefined`、`null`报错

```js
Object.getPrototypeOf(1) === Number.prototype // true
Object.getPrototypeOf('foo') === String.prototype // true
Object.getPrototypeOf(true) === Boolean.prototype // true
```

### keys()、values()、entries()

*ES5*`Object.keys`：返回一个数组，成员是参数对象自身的（*不含继承*）所有*可遍历*属性的*键名*。

*ES2017*

`Object.values`：返回一个数组，成员是参数对象自身的（*不含继承*）所有*可遍历*属性的*键值*。

> 值为字符串，返回字符串组成的数组
>
> 数值、布尔值，返回空数组（不是对象转对象，而这两者包装对象都不会添加非继承属性）

`Object.entries()`：返回一个数组，成员是参数对象自身的（*不含继承*）所有*可遍历 ( 非Symbol )*属性的*键值对*数组。

- 可将对象转为 `Map` 结构

```js
const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: "bar", baz: 42 }
```

手写`Oject.enteries`

```js
// Generator函数的版本
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

// 非Generator函数的版本
function entries(obj) {
  let arr = [];
  for (let key of Object.keys(obj)) {
    arr.push([key, obj[key]]);
  }
  return arr;
}
```

### formEntries()

`Object.fromEntries()`：`Object.entries()`的逆操作，用于将一个*键值对数组*转为*对象*。

适合将 Map 结构转为对象

```js
const map = new Map().set('foo', true).set('bar', false);
Object.fromEntries(map)
// { foo: true, bar: false }
```

配个`URLSearchParams`对象，查询字符串转对象

```js
Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'))
// { foo: "bar", baz: "qux" }
```
