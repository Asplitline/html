

## Symbol

*ES6* 引入**原始数据类型**`Symbol`，*独一无二的值*。

- 原始类型 不能用`new`

JavaScript 数据类型，前六种是：`undefined`、`null`、`Boolean`、`String`、`Number`、`Object`。

`Symbol()`：生成Symbol值

- 参数为*字符串*，只用于区分，相等不代表`Symbol`值相等
- 参数为*对象*，调用 `toString`方法，将其转为字符串
- 不能与其他类型进行运算
- Symbol能转为*布尔值*，*不能转为数值*

对象的属性名有两种类型，一种是*字符串*，另一种是*Symbol 类型*。

### Symbol.prototype.description

创建 Symbol 的时候，可以添加一个描述。

```js
const sym = Symbol('foo');

String(sym) // "Symbol(foo)"
sym.toString() // "Symbol(foo)"

sym.description // "foo"
```

*ES2019* 提供实例属性 `description`，返回Symbol描述

### 作为属性名的Symbol

Symbol作为属性，保证不会出现同名属性

- Symbol作为对象属性，**不能用点运算符**，*点运算符后面总是字符串*
- 对象内部，Symbol值定义属性，**必须放到方括号中**，否则键名为字符串，而非Symbol值
- Symbol 值作为属性名时，该属性还是公开属性，不是私有属性

```js
const mySymbol = Symbol();
const a = {};

a.mySymbol = 'Hello!'; // mySymbol 会转为 字符串
a[mySymbol] // undefined
a['mySymbol'] // "Hello!"

let s = Symbol();
let obj = {
  [s]: function (arg) { ... }
};

obj[s](123);
```

### 消除魔术字符串

**魔术字符串**：代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。

`Triangle`为魔术字符串

- 通过变量消除
- 实际变量值并不重要，通过`Symbol`消除

```js
function getArea() {
  switch (shape) {
    case 'Triangle': // 魔术字符串
    /* ... more code ... */
  }
  return area;
}
getArea('Triangle'); // 魔术字符串

const shapeType = {
  triangle: 'Triangle'
};
getArea(shapeType.triangle);

const shapeType = {
  triangle: Symbol()
};
```

### 属性名变量

Symbol不会出现在`for...in`、`for...of`、`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`中

`Object.getOwnPropertySymbols()`：获取指定对象的所有 Symbol 属性名。返回数组，成员为所有作*属性名的Symbol值*

`Reflect.ownKeys()`：返回*所有类型的键名*（包括Symbol 键名）

>  *Symbol 值作为键名，不会被常规方法遍历得*到这一特性，可以为对象定义一些非私有的、但又希望只用于内部的方法

```js
let size = Symbol('size');

class Collection {
  constructor() {
    this[size] = 0;
  }

  add(item) {
    this[this[size]] = item;
    this[size]++;
  }

  static sizeOf(instance) {
    return instance[size];
  }
}

let x = new Collection();
Collection.sizeOf(x) // 0

x.add('foo'); // 0:'foo' Symbol(size): 1
Collection.sizeOf(x) // 1

Object.keys(x) // ['0']
Object.getOwnPropertyNames(x) // ['0']
Object.getOwnPropertySymbols(x) // [Symbol(size)]
```

### Symbol.for()，Symbol.keyFor()

`Symbol.for()`：接受一个字符串作为参数，搜索以*该参数作为名称*的 Symbol 值。

- 有，返回Symbol值
- 无，以该字符串*新建*为名称的 Symbol 值，*直接注册到全局，不管有没有在全局变量*

> `Symbol.for()`与`Symbol()`区别
>
> `Symbol.for()`在全局变量搜索，不存在才会新建。`Symbol()`直接新建

`Symbol.keyFor()`：返回一个已登记的 Symbol 类型值的`key`

```js
let s1 = Symbol.for("foo");
Symbol.keyFor(s1) // "foo"

let s2 = Symbol("foo");
Symbol.keyFor(s2) // undefined
```

`Symbol.for()`全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。

```js
iframe = document.createElement('iframe');
iframe.src = String(window.location);
document.body.appendChild(iframe);

iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo') // true
```

### 模块的 Singleton 模式

`Singleton 模式`：调用一个类，任何时候返回的都是同一个实例。

```js
// mod.js// 
const FOO_KEY = Symbol.for('foo');
function A() {  
    this.foo = 'hello';
}
if (!global._foo) {  
    global._foo = new A();
}
/*if (!global[FOO_KEY]) {  global[FOO_KEY] = new A();}*/
module.exports = global._foo;// module.exports = global[FOO_KEY];
```

**缺陷**：`global._foo`为可写，任何文件都可以修改，在引入前修改值

**解决**：利用Symbol，但也有问题，多次执行，每次`FOO_KEY`不一样。虽然 Node 会将脚本的执行结果缓存，但用户可以手动清除缓存，所以*也不是绝对可靠*

```js
global._foo = { foo: 'world' };
const a = require('./mod.js');
```

### 内置Symbol

`Symbol.hasInstance`属性：指向一个内部方法。使用`instanceof`运算符，*判断是否为该对象的实例*时，会调用这个方法。

```js
class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array;
  }
}

[1, 2, 3] instanceof new MyClass() // true
```

`Symbol.isConcatSpreadable`属性：等于一个布尔值，表示对象用于`Array.prototype.concat()`时，*是否可以展开*。

- **数组**：默认(`undefined`)可展开
- **类数组**：默认（`undefined`）不展开，值为`true`才可展开

```js
let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
```

```js
let obj = {length: 2, 0: 'c', 1: 'd'};
['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']

obj[Symbol.isConcatSpreadable] = true;
['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']
```

`Symbol.species`属性：指向一个*构造函数*。创建衍生对象时，会使用该属性。

- 定义`Symbol.species`属性要采用`get`取值器。

此代码，*b，c均为a*的衍生对象。

```js
class MyArray extends Array {
}

const a = new MyArray(1, 2, 3);
const b = a.map(x => x);
const c = a.filter(x => x > 1);

b instanceof MyArray // true
c instanceof MyArray // true
```

```js
class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}

const a = new MyArray();
const b = a.map(x => x);

b instanceof MyArray // false
b instanceof Array // true
```

**应用**：子类使用继承的方法，希望*返回基类的实例*，而不是子类的实例。

`Symbol.match`属性：指向一个函数。执行`str.match(myObject)`，如果该属性存在，会调用它，返回该方法的返回值。

```js
String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)

class MyMatcher {
  [Symbol.match](string) {
    return 'hello world'.indexOf(string);
  }
}
'e'.match(new MyMatcher()) // 1
```

`Symbol.replace`属性：指向一个方法，当该对象被`String.prototype.replace`方法调用时，会返回该方法的返回值。

```js
String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)

const x = {};
x[Symbol.replace] = (...s) => console.log(s);

'Hello'.replace(x, 'World') // ["Hello", "World"]
```

`Symbol.search`属性：指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。

```js
String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)
```

`Symbol.split`属性：指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。

```js
String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)
```

`Symbol.iterator`属性：指向该对象的*默认遍历器*方法。

- 进行`for...of`循环时，调用`Symbol.iterator`方法，返回该对象的默认遍历器

```js
class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2
```

`Symbol.toPrimitive`属性：指向一个方法。该*对象被转为原始类型的值*时，会调用这个方法，返回该对象对应的原始类型值。

`Symbol.toPrimitive`被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。

- Number：该场合需要转成数值
- String：该场合需要转成字符串
- Default：该场合可以转成数值，也可以转成字符串

```js
let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'number':
        return 123;
      case 'string':
        return 'str';
      case 'default':
        return 'default';
      default:
        throw new Error();
     }
   }
};

2 * obj // 246
3 + obj // '3default'
obj == 'default' // true
String(obj) // 'str'
```

`Symbol.toStringTag`属性：指向一个方法。在对象上面调用`Object.prototype.toString`方法时调用

- 属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型
- 可以用来定制`[object Object]`或`[object Array]`中`object`后面的那个字符串。

```js
// 例一
({[Symbol.toStringTag]: 'Foo'}.toString())
// "[object Foo]"

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return 'xxx';
  }
}
let x = new Collection();
Object.prototype.toString.call(x) // "[object xxx]"
```

`Symbol.unscopables`属性：指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。

通过指定`Symbol.unscopables`属性，使得`with`语法块不会在当前作用域寻找`foo`属性，即`foo`将指向外层作用域的变量。

```js
// 没有 unscopables 时
class MyClass {
  foo() { return 1; }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 1
}

// 有 unscopables 时
class MyClass {
  foo() { return 1; }
  get [Symbol.unscopables]() {
    return { foo: true };
  }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 2
}
```

## Set和Map

### Set

#### Set基本用法

*类似数组，成员值唯一，没有重复值*

`Set`本身是一个构造函数，用来生成 Set 数据结构。

- **参数**：*数组* 或 *具有iterable接口的其他数据结构*

`add()`：向 Set 结构加入成员，**不会添加重复的值**。

- 加入值不会发生类型转换
- 内部判断值，类似`===`
- *set内部值判断*认为`NaN`等于自身，`===`认为`NaN`不等于自身
- 两个空对象不相等，视为两个值

```js
[...new Set(array)] // 数组去重
[...new Set(string)].join('') // 字符串去重
```

#### 实例属性和方法

`Set.prototype.constructor`：*构造函数*，默认就是`Set`函数

`Set.prototype.size`：返回`Set`实例的*成员总数*

Set 实例方法分为：*操作方法*（用于操作数据）和*遍历方法*（用于遍历成员）

##### 操作方法

`Set.prototype.add(value)`：*添加*某个值，*返回* Set 结构*本身*

`Set.prototype.delete(value)`：*删除*某个值，*返回布尔值*，表示删除是否成功

`Set.prototype.has(value)`：*返回布尔值*，表示该值是否为`Set`的成员

`Set.prototype.clear()`：*清除所有*成员，*没有返回值*

##### 遍历方法

`Set.prototype.keys()`：返回*键名*的遍历器

`Set.prototype.values()`：返回*键值*的遍历器

`Set.prototype.entries()`：返回*键值对*的遍历器

`Set.prototype.forEach()`：使用回调函数*遍历每个成员*

*`Set`遍历顺序就是插入顺序*。exp：保存回调函数列表，调用时能保证按照添加顺序

*Set结构没有键名*。`keys`和`values`行为一致

```js
let set = new Set(['red', 'green', 'blue']);

for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
```

*Set结构实例默认可遍历*，可以省略`values`用 `for...of`遍历

```js
Set.prototype[Symbol.iterator] === Set.prototype.values // true
```

*扩展运算符*（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构

数组方法*间接*用于set

```js
let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));

let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
let union = new Set([...a, ...b]); // 并集
let intersect = new Set([...a].filter(x => b.has(x))); // 交集
let difference = new Set([...a].filter(x => !b.has(x))); // 差集
```

*遍历中同步改变Set结构*

1. 利用Set结构*映射*，*赋值*给原来的Set
2. 利用`Array.form`

```js
// 1
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// 2
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
```

### WeakSet

*与set结构类似，不重复值的集合*

**区别**

- `WeakSet`成员*只能是对象*
- `WeakSet`中对象为*弱引用*，其他对象不引用该对象，自动回收，*不考虑是否还在`WeakSet`中*。
- `WeakSet`的成员随时可能消失，遍历机制无法保证成员的存在，不可预测。*ES6*规定`WeakSet`不可遍历

```js
const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
```

`WeakSet` 是一个*构造函数*，可以使用`new`命令，创建 *WeakSet 数据结构*。

- **参数**：*数组*或*类似数组的对象*
  - 任何具有 iterable接口的对象都可作参数
  - 数组*所有成员*，自动成为WeakSet*实例对象成员*。

```js
const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
```

**数组成员为WeakSet成员，而不是数组本身**，下面`b`数组成员不是对象，报错

```js
const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
```

`WeakSet.prototype.add(value)`：向 WeakSet 实例*添加*一个新成员。

`WeakSet.prototype.delete(value)`：*清除* WeakSet 实例的指定成员。

`WeakSet.prototype.has(value)`：*返回布尔值*，表示某个值是否在 WeakSet 实例之中。

WeakSet 没有`size`属性，没有办法遍历它的成员。

**好处**：存储DOM节点，不担心节点从文档移除，引发内存泄漏

下面代码保证了`Foo`的实例方法，只能在`Foo`的实例上调用。

使用 WeakSet 的好处是：`foos`对实例的引用，不会被计入内存回收机制，所以删除实例，不用考虑`foos`，也不会出现内存泄漏。

```js
const foos = new WeakSet()
class Foo {
  constructor() {
    foos.add(this)
  }
  method () {
    if (!foos.has(this)) {
      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
    }
  }
}
```

### Map

#### Map基本使用

*对象*（`Object`）：键值对的集合（Hash 结构），实际只能用字符串作键值

*ES6* **Map**数据结构：键值对集合，*各种类型都能为键*

- *数组*，*任何具有`iterator`接口*且每个成员都是*双元素*的*数组数据结构*都能作Map构造函数参数
- *同一键*多次赋值，*后面值覆盖前面*
- 读取*未知键*，`undefind`

```js
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

// 等效
const items = [
  ['name', '张三'],
  ['title', 'Author']
];
const map = new Map();
items.forEach(
  ([key, value]) => map.set(key, value)
);
```

`Set`和`Map`都可以用来生成新的 Map

```js
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
```

**对同一对象的引用，Map结构才视其为同一键**

Map 的键跟*内存地址绑定*的，只要内存地址不一样，就视为两个键。

```js
const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
```

*简单类型值*：严格相等，就视为同一键

> 例外：NaN，不严格等于自身，但视为同一键

#### 实例属性和操作方法

`size`属性：返回 Map 结构的*成员总数*

##### 操作方法

`set`方法：设置键名`key`对应的键值为`value`，然后*返回整个 Map 结构*，因此*可链式运算*

- 有值更新，无值新增

`get`方法：读取`key`对应的键值。找不到`key`，返回`undefined`

`has`方法：*返回布尔值*，表示某个键*是否在*当前 *Map 对象之中*

`delete`方法：*删除*某个键，返回`true`。如果删除失败，返回`false`

`clear`方法：*清除*所有成员，*无返回值*

##### 遍历方法

`Map.prototype.keys()`：返回*键名*的遍历器

`Map.prototype.values()`：返回*键值*的遍历器

`Map.prototype.entries()`：返回*所有成员*的遍历器

`Map.prototype.forEach()`：*遍历* Map 的*所有*成员

`Map` 结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。

```js
map[Symbol.iterator] === map.entries // true

for (let [key, value] of map) {
  console.log(key, value);
}
for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
```

#### 结构转换

*Map转数组结构*：使用扩展运算符`...`

同Set，*可以结合数组方法*。

```js
const map0 = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');

const map1 = new Map(
  [...map0].filter(([k, v]) => k < 3)
);
// Map 结构 {1 => 'a', 2 => 'b'}
```

*数组转Map*：数组传入Map构造函数

```js
new Map([
  [true, 7],
  [{foo: 3}, ['abc']]
])
// Map {
//   true => 7,
//   Object {foo: 3} => ['abc']
// }
```

*Map转对象*：Map键为字符串，无损转对象，非字符串，会先转为字符串。

```js
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set('yes', true)
  .set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
```

*对象转Map*：通过`Object.entries()`

```js
let obj = {"a":1, "b":2};
let map = new Map(Object.entries(obj));
```

自己实现转换函数

```js
function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {"yes" => true, "no" => false}
```

*Map转JSON*

Map键名*都为*字符串，转为*对象JSON*

```js
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{"yes":true,"no":false}'
```

Map键名*有非*字符串，转为*数组JSON*

```js
function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{"foo":3},["abc"]]]'
```

*JSON转Map*

所有键名为字符串

```js
function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes": true, "no": false}')
// Map {'yes' => true, 'no' => false}
```

JSON为数组，数组成员有两个成员数组

```js
function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
// Map {true => 7, Object {foo: 3} => ['abc']}
```

### WeakMap

与`Map`结构类似，也是用于生成键值对的集合。

- `WeakMap`*只接受对象*作为键名（`null`除外），不接受其他类型的值作为键名（*会报错*）
- **弱引用，同`WeakSet`，该对象其他引用清除，自动回收**

下面代码，需要*手动删除*引用，否则*不会自动释放内存*

```js
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
  [e1, 'foo 元素'],
  [e2, 'bar 元素'],
];
arr[0] = null
arr[1] = null
```

总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。

**弱引用的是键名，不是键值**

```js
const wm = new WeakMap();
let key = {};
let obj = {foo: 1};

wm.set(key, obj);
obj = null;
wm.get(key)
// Object {foo: 1}
```

**WeakMap和Map区别**

- *没有遍历操作*。没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。
  - 没有`size`属性、`keys()`、`values()`和`entries()`方法
- *无法清空*，不支持`clear`
  - 只有 `get()`、`set()`、`has()`、`delete()`

**WeakMap用途**

 *DOM 节点作为键名*

`document.getElementById('logo')`是一个 DOM 节点，每当发生`click`事件，就更新一下状态

将状态作为键值放在 WeakMap ，对应的键名为节点对象

一旦 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险

```js
let myWeakmap = new WeakMap();

myWeakmap.set(
  document.getElementById('logo'),
  {timesClicked: 0})
;

document.getElementById('logo').addEventListener('click', function() {
  let logoData = myWeakmap.get(document.getElementById('logo'));
  logoData.timesClicked++;
}, false);
```

*部署私有属性*

`Countdown`类的两个内部属性`_counter`和`_action`，是实例的弱引用

删除实例，它们也就随之消失，不会造成内存泄漏

```js
const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter < 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

const c = new Countdown(2, () => console.log('DONE'));

c.dec()
c.dec()
// DONE
```

## Proxy

*Proxy* ：目标对象之前*拦截*，外界对该对象的访问，都必须先通过这层拦截。

> 属于*元编程*（meta programming），即对编程语言进行编程。

*ES6* 提供 `Proxy`构造函数，生产Proxy实例

```js
var proxy = new Proxy(target, handler);
```

- `target`：所要拦截目标对象
  - `type:Object`
- `handler`：定制拦截行为
  - `type:Object`

*没有定制拦截，直接通向原对象*，访问`proxy`等于访问`target`

```js
var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = 'b';
target.a // "b"
```

**技巧**：

将 Proxy 对象，设置到`object.proxy`属性，可以在`object`对象上调用

```js
var object = { proxy: new Proxy(target, handler) };
```

Proxy 实例也可作为其他对象的*原型对象*

```js
var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
```

### Proxy 实例方法

#### Proxy.get

`get(target, propKey, receiver)`：拦截对象属性的*读取*

- `target`：目标对象
- `propKey`：属性名
- `reciver`（可选）：Proxy或继承Proxy对象
  - 指向原始的*读操作所在那个对象*，一般情况下就是 Proxy 实例

```js
const proxy = new Proxy({}, {
  get: function(target, key, receiver) {
    return receiver;
  }
});

proxy.getReceiver === proxy // true

const d = Object.create(proxy);
d.a === d // true
```

`d`对象本身没有`a`属性，`d`会去原型`proxy`对象寻找，此时 `receiver`指向`d`，代表原始读操作那个对象

> 属性不可配置（`configurable`）且不可写（`writable`），则 Proxy 不能修改该属性

**用法**：

*`get`可以继承*

```js
let proto = new Proxy({}, {
  get(target, propertyKey, receiver) {
    console.log('GET ' + propertyKey);
    return target[propertyKey];
  }
});

let obj = Object.create(proto);
obj.foo // "GET foo"
```

*实现属性链式操作*

```js
var pipe = function (value) {
  var funcStack = [];
  var oproxy = new Proxy({} , {
    get : function (pipeObject, fnName) {
      // 非get, 函数入栈
      if (fnName === 'get') {
        return funcStack.reduce(function (val, fn) {
          // double(3) - 6
          // pow(6) - 36
          // reverseInt(36) - 63
          return fn(val);
        },value);
      }
      funcStack.push(window[fnName]);
      return oproxy;
    }
  });

  return oproxy;
}

var double = n => n * 2;
var pow    = n => n * n;
var reverseInt = n => n.toString().split("").reverse().join("") | 0;

pipe(3).double.pow.reverseInt.get; // 63
```

*生成各种 DOM 节点的通用函数`dom`*

```js
const dom = new Proxy({}, {
  get(target, property) {
    // attrs - 属性
    // children - 子元素
    return function(attrs = {}, ...children) {
      const el = document.createElement(property);
      for (let prop of Object.keys(attrs)) {
        el.setAttribute(prop, attrs[prop]);
      }
      for (let child of children) {
        // 为字符串，创建文本节点
        if (typeof child === 'string') {
          child = document.createTextNode(child);
        }
        el.appendChild(child);
      }
      return el;
    }
  }
});

const el = dom.div(
   {},
  'Hello, my name is ',
  dom.a(
    {href: '//example.com'}, 'Mark'),
  	'. I like:',
  dom.ul(
    {},
    dom.li({}, 'The web'),
    dom.li({}, 'Food'),
    dom.li({}, '…actually that\'s it')
  )
);

document.body.appendChild(el);
```

#### Proxy.Set

`set(target, propKey, value, receiver)`：拦截对象属性的*设置*

- `target`：目标对象
- `propKey`：属性名
- `value`：属性值
- `receiver`（可选）：...

> 某个属性不可写（`writable`），`set`不起作用
>
> `set`代理应当返回一个布尔值。在严格模式下，`set`代理如果没有返回`true`，就会报错

*防止内部属性被外部读写*

```js
const handler = {
  get (target, key) {
    invariant(key, 'get');
    return target[key];
  },
  set (target, key, value) {
    invariant(key, 'set');
    target[key] = value;
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === '_') {
    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
  }
}
const target = {};
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private "_prop" property
proxy._prop = 'c'
// Error: Invalid attempt to set private "_prop" property
```

#### Proxy.apply

`apply(target, object, args)`：拦截 Proxy 实例作为函数调用的操作，拦截函数的调用、`call`和`apply`操作

- `target`：目标对象
- `object`：目标对象上下文（`this`）
- `args`：目标对象参数数组

```js
var twice = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments) * 2;
  }
};
function sum (left, right) {
  return left + right;
};
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30
Reflect.apply(proxy, null, [9, 10]) // 38
```

> 调用`Reflect.apply`方法，也会被拦截

#### Proxy.has

`has(target, propKey)`：拦截`HasProperty`操作，返回一个布尔值。exp：`in`运算符

- `target`：目标对象
- `propKey`：需查询属性名

拦截`HasProperty`操作，而不是`HasOwnProperty`操作，*不管自身还是继承*属性

`has()`对`for...in`*不生效*

> 对象不可配置（`configurable`），或禁止扩展，has拦截报错

```js
var obj = { a: 10 };
Object.preventExtensions(obj); // 禁止扩展
```

*隐藏属性*

```js
var handler = {
  has (target, key) {
    if (key[0] === '_') {
      return false;
    }
    return key in target;
  }
};
var target = { _prop: 'foo', prop: 'foo' };
var proxy = new Proxy(target, handler);
'_prop' in proxy // false
```

#### Proxy.construct

`construct(target, args)`：拦截 Proxy 实例作为构造函数调用的(`new`)操作

- `target`：目标对象，由于拦截构造函数，所以必须是函数

- `args`：构造函数的参数数组

- `newTarget`：创造实例对象时，`new`命令作用的*构造函数*

- **返回值**：返回一个对象，否则会报错

- **this**：指向`handler`，而非实例对象

  ```js
  const handler = {
    construct: function(target, args) {
      console.log(this === handler);
      return new target(...args);
    }
  }
  
  let p = new Proxy(function () {}, handler);
  new p() // true
  ```

#### Proxy.deleteProperty

`deleteProperty(target, propKey)`：拦截`delete`的操作，返回一个布尔值。方法*抛出错误*或*返回`false`*，当前属性无法被`delete`删除

拦截后需要*手动`delete`*

> 目标对象自身的不可配置（`configurable`）的属性，无法删除，否则报错

#### Proxy.defineProperty

`defineProperty(target, propKey, propDesc)`：拦截`Object.defineProperty`、`Object.defineProperties`，返回一个布尔值。

**只是拦截，需要重写逻辑**

>*目标对象*不可扩展（`non-extensible`），`defineProperty()`不能增加目标对象上不存在的属性
>
>目标对象*某个属性*不可写（`writable`）或不可配置（`configurable`），`defineProperty()`方法不得改变这两个设置

#### Proxy.getOwnPropertyDescriptor

`getOwnPropertyDescriptor(target, propKey)`：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回*属性的描述对象*或*undefined*。

#### Proxy.getPrototypeOf

`getPrototypeOf(target)`：拦截*获取对象原型*，返回一个对象（必须是`object`或`null`）。

拦截下面操作

- `Object.prototype.__proto__`
- `Object.prototype.isPrototypeOf()`
- `Object.getPrototypeOf()`
- `Reflect.getPrototypeOf()`
- `instanceof`

> 目标对象不可扩展（`non-extensible`）， `getPrototypeOf()`方法必须返回目标对象的原型对象

#### Proxy.isExtensible

`isExtensible(target)`：拦截`Object.isExtensible(proxy)`，返回一个布尔值。

- 只能返回布尔值，其他值会自动转为布尔
- **强限制**：返回值必须与目标对象的`isExtensible`属性保持一致，否则抛出错误

#### Proxy.ownKeys

`ownKeys(target)`：该返回*目标对象所有*自身的属性的*属性名*

- 必须返回**数组**，且数组成员为**字符串**或**Symbol**
- 不可配置成员*必须返回*
- 目标对象是不可扩展的（non-extensible），*必须返回原对象的所有属性*，且*不能包含多余属性*

拦截下面操作

- `Object.getOwnPropertyNames()`
- `Object.getOwnPropertySymbols()`
- `Object.keys()`
- `for...in`循环

**注意**：`Object.keys()`：返回结果仅包括目标对象自身的*可遍历属性*

`Object.keys()`自动过滤以下三类属性，不会返回

- 目标对象上不存在的属性
- 属性名为 Symbol 值
- 不可遍历（`enumerable`）的属性



#### Proxy.preventExtensions

`preventExtensions(target)`：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。

- **限制**：只有目标对象不可扩展（即`Object.isExtensible(proxy)`为`false`），`proxy.preventExtensions`才能返回`true`
- **解决**：在`proxy.preventExtensions()`方法里面，调用一次`Object.preventExtensions()`

```js
var proxy = new Proxy({}, {
  preventExtensions: function(target) {
    console.log('called');
    Object.preventExtensions(target);
    return true;
  }
});

Object.preventExtensions(proxy)
// "called"
// Proxy {}
```

#### Proxy.setPrototypeOf

`setPrototypeOf(target, proto)`：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。

- 只能返回布尔值，否则会被自动转为布尔值

> 目标对象不可扩展（`non-extensible`），`setPrototypeOf()`方法不得改变目标对象的原型

### Proxy.revocable()

`Proxy.revocable()`：返回一个*可取消*的 Proxy 实例

```js
let target = {};
let handler = {};

let {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
```

**使用场景**：目标对象*不允许直接*访问，必须通过*代理访问*，一旦访问结束，就收回代理权，不允许再次访问。

### this问题

Proxy 代理针对目标对象的访问，不是目标对象的透明代理。

即不做任何拦截，也无法保证与目标对象行为一致。

**主要原因**：

Proxy 代理下，*目标对象内部*的`this`关键字会指向 `Proxy` 代理

无法代理*目标对象*

```js
const _name = new WeakMap();

class Person {
  constructor(name) {
    _name.set(this, name);
  }
  get name() {
    return _name.get(this);
  }
}

const jane = new Person('Jane');
jane.name // 'Jane'

const proxy = new Proxy(jane, {});
proxy.name // undefined
```

无法代理*原生对象属性*

**解决**：`this`绑定原始对象

```js
const target = new Date();
const handler = {};
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.
```

```js
const target = new Date('2015-01-01');
const handler = {
  get(target, prop) {
    if (prop === 'getDate') {
      return target.getDate.bind(target);
    }
    return Reflect.get(target, prop);
  }
};
const proxy = new Proxy(target, handler);

proxy.getDate() // 1
```

Proxy *拦截函数内部*的`this`，指向的是`handler`对象

```js
const handler = {
  get: function (target, key, receiver) {
    console.log(this === handler);
    return 'Hello, ' + key;
  },
  set: function (target, key, value) {
    console.log(this === handler);
    target[key] = value;
    return true;
  }
};

const proxy = new Proxy({}, handler);

proxy.foo
// true
// Hello, foo

proxy.foo = 1
// true
```

## Reflect

`Reflect`对象设计目的如下

- 将`Object`对象属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。**从`Reflect`对象上可以拿到语言内部的方法**

> 现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。

-  **修改某些`Object`方法的返回结果**，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`

```js
// 老写法
try {
  Object.defineProperty(target, property, attributes);
  // success
} catch (e) {
  // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}
```

-  **让`Object`操作都变成函数行为**，某些`Object`操作是命令式。比如`name in obj`和`delete obj[name]`

```js
// 老写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
```

- `Reflect`对象的方法与`Proxy`对象的方法一一对应。不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。

`Proxy`方法拦截`target`对象属性赋值行为。采用`Reflect.set`方法将值赋给对象属性，**确保默认行为，再部署额外功能**

```js
Proxy(target, {
  set: function(target, name, value, receiver) {
    var success = Reflect.set(target, name, value, receiver);
    if (success) {
      console.log('property ' + name + ' on ' + target + ' set to ' + value);
    }
    return success;
  }
});
```

`Reflect`对象，*使操作更易读*

```js
// 老写法
Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

// 新写法
Reflect.apply(Math.floor, undefined, [1.75]) // 1
```

### 静态方法

`Reflect`对象一共有 13 个静态方法，与`proxy`一一对应

#### Reflect.get

`Reflect.get(target, name, receiver)`：*查找并返回*`target`对象的`name`属性。没有属性，返回`undefined`

- *属性*部署了读取函数（getter），**读取函数`this`绑定`receiver`**
- 第一个参数*不是对象*，`Reflect.get`方法报错

#### Reflect.set

`Reflect.set(target, name, value, receiver)`：*设置*`target`对象的`name`属性等于`value`

- *属性*部署了赋值函数(setter)，**赋值函数`this`绑定`receiver`**
- 第一个参数*不是对象*，`Reflect.get`方法报错
- 传入了`receiver`，那么`Reflect.set`会触发`Proxy.defineProperty`拦截。
  - `receiver`默认指向当前`Proxy`实例（`obj`）
  - 传入`receiver`，赋值函数会将属性赋值到`recevier`上（也就是`obj`）
  - 导致触发`defineProperty`拦截

```js
let p = {
  a: 'a'
};

let handler = {
  set(target, key, value, receiver) {
    console.log('set');
    Reflect.set(target, key, value, receiver)
    Reflect.set(target, key, value) // 不会触发 defineProperty
  },
  defineProperty(target, key, attribute) {
    console.log('defineProperty');
    Reflect.defineProperty(target, key, attribute);
  }
};

let obj = new Proxy(p, handler);
obj.a = 'A';
// set
// defineProperty
```

#### Reflect.has

`Reflect.has(target, name)`：对应`name in obj`里面的*`in`运算符*

- 第一个参数*不是对象*，`Reflect.has`方法报错

```js
// 旧写法
'foo' in myObject // true
// 新写法
Reflect.has(myObject, 'foo') // true
```

#### Relect.deleteProperty

`Reflect.deleteProperty(target, name)`：对应`delete obj[name]`，用于*删除对象*的属性

```js
// 旧写法
delete myObj.foo;
// 新写法
Reflect.deleteProperty(myObj, 'foo');
```

#### Reflect.construct

`Reflect.construct(target, args)`：对应`new target(...args)`，一种不使用`new`，来*调用构造函数*的方法

```js
// new 的写法
const instance = new Greeting('张三');
// Reflect.construct 的写法
const instance = Reflect.construct(Greeting, ['张三']);
```

#### Reflect.getPrototypeOf

`Reflect.getPrototypeOf(target)`：对应`Object.getPrototypeOf(obj)`，*读取*对象的`__proto__`属性

- `Object`中参数不为对象，会转为对象再运行，`Reflect`中参数不为对象，会报错

```js
// 旧写法
Object.getPrototypeOf(myObj) === FancyThing.prototype;
// 新写法
Reflect.getPrototypeOf(myObj) === FancyThing.prototype;
```

#### Reflect.setPrototypeOf

`Reflect.setPrototypeOf(target, prototype)`：对应`Object.setPrototypeOf(obj, newProto)`，设置*目标对象的原型*（prototype），返回布尔值，表示是否设置成功

- `Object`中参数不为对象，会转为对象再运行，`Reflect`中参数不为对象，会报错（*第一参数*）
- `undefined`和`null`均会报错（*第一参数*）
- 无法设置（目标对象禁止扩展），也返回`false`

```js
// 旧写法
Object.setPrototypeOf(myObj, Array.prototype);
// 新写法
Reflect.setPrototypeOf(myObj, Array.prototype);
```

#### Reflect.apply

`Reflect.apply(target, thisArg, args)`：对应`Function.prototype.apply.call(func, thisArg, args)`，用于*绑定`this`对象*后*执行给定函数*

*绑定函数`this`对象*

```js
fn.apply(obj, args)
// 函数本身定义了apply
Function.prototype.apply.call(fn, obj, args)
```

```js
const ages = [11, 33, 12, 54, 18, 96];
// 旧写法
const youngest = Math.min.apply(Math, ages);
const oldest = Math.max.apply(Math, ages);
const type = Object.prototype.toString.call(youngest); // "[object Number]"
// 新写法
const youngest = Reflect.apply(Math.min, Math, ages);
const oldest = Reflect.apply(Math.max, Math, ages);
const type = Reflect.apply(Object.prototype.toString, youngest, []);
```

#### Reflect.defineProperty

`Reflect.defineProperty(target, name, desc)`：对应`Object.defineProperty`，用来*为对象定义属性*

- `target`：不是对象，会报错

```js
// 旧写法
Object.defineProperty(MyDate, 'now', {
  value: () => Date.now()
});

// 新写法
Reflect.defineProperty(MyDate, 'now', {
  value: () => Date.now()
});
```

#### Reflect.getOwnPropertyDescriptor

`Reflect.getOwnPropertyDescriptor(target, name)`：对应`Object.getOwnPropertyDescriptor`，用于*得到指定属性的描述对象*

- `target`：不是对象，会报错

```js
var myObject = {};
Object.defineProperty(myObject, 'hidden', {
  value: true,
  enumerable: false,
});

// 旧写法
var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');
// 新写法
var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');
```

#### Reflect.isExtensible

`Reflect.isExtensible(target)`：对应`Object.isExtensible`，返回一个布尔值，表示当前*对象是否可扩展*

- `Object.isExtensible`参数不为对象，返回`false`（非对象本身就不可扩展）
- `Reflect.isExtensible`会报错

```js
// 旧写法
Object.isExtensible(myObject) // true
// 新写法
Reflect.isExtensible(myObject) // true
```

#### Reflect.preventExtensions

`Reflect.preventExtensions(target)`：对应`Object.preventExtensions`方法，*让对象变为不可扩展*。它返回一个布尔值，表示是否操作成功

- `Object.preventExtensions`参数不是对象，*ES5*报错，*ES6*返回传入参数
- `Reflect.preventExtensions`会报错

```js
// 旧写法
Object.preventExtensions(myObject) // Object {}
// 新写法
Reflect.preventExtensions(myObject) // true
```

#### Reflect.ownKeys

`Reflect.ownKeys(target)`：等同`Object.getOwnPropertyNames`与`Object.getOwnPropertySymbols`之和，返回对象的*所有属性*

- `target`：不是对象，报错

###  实现观察者模式

*观察者模式*（Observer mode）：指的是函数自动观察数据对象，*一旦对象有变化，函数就会自动执行*

```js
const person = observable({
  name: '张三',
  age: 20
});

function print() {
  console.log(`${person.name}, ${person.age}`)
}

observe(print); // 将print加入观察者函数队列
person.name = '李四';
// 李四, 20
```

```js
const queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn); // 观察者函数
const observable = obj => new Proxy(obj, {set}); // 观察者对象

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer()); // 调用队列中函数
  return result;
}
```

## Promise

`Promise`，保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

`Promise` 是一个对象，可以获取异步操作的消息。

- 对象状态不受外界影响，**只有异步操作可以决定当前状态**
  - `pending`：进行中
  - `fulfilled`：已成功
  - `rejected`：已失败
- **状态一旦改变，就不会再变**
  - 两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`
  - 状态改变后，添加回调函数，会*立即得到结果*。而事件是错过了再去监听，无法得到结果

**优点**

- 异步操作以同步操作流程表达，避免回调地狱
- Promise对象提供统一接口，控制异步操作更容易

**缺点**

- 一旦执行，无法中途取消`Promise`
- 不设回调，`Promise`内部错误，不会反应到外部
- 处于`pending`状态，无法得知目前到哪一阶段（*刚刚开始* 或 *即将完成*）

### 基本用法

*ES6* `Promise`对象是一个构造函数，用来生成`Promise`实例

`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。

- `resolve`：将`Promise`对象的状态从`pending` 变为 `resolved`，在异步操作*成功时*调用，并将异步操作的*结果作为参数传递*出去
- `reject`：将`Promise`对象的状态从`pending` 变为 `rejected`，在异步操作*失败时*调用，并将异步操作的*错误作为参数传递*出去

`Promise`实例，用`then`方法两个参数分别指定`resolved`状态和`rejected`状态的回调函数

```js
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```

*`p1`状态会传递给`p2`*

- 如果`p1`是`pending`，`p2`回调**等待**`p1`状态改变
- 如果`p1`状态时`resolved`或`rejected`，`p2`回调立刻执行

`1s`后`p2`返回`p1`，导致`p2`状态失效，`3s`后，`p1`变为`reject`，导致`p2`触发`catch`

```js
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
```

​	*``resolve或`reject`不会终结`promise参数执行*

 `resolved` 的 `Promise` 是在本轮*事件循环的末尾执行*，总是*晚于*本轮循环的*同步任务*

```js
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2); // 2
}).then(r => {
  console.log(r); // 1
});
```

### Promise.prototype

`Promise.prototype.then()`：定义在对象原型上，为`Promise`实例添加状态改变时回调函数

- `then`方法返回**新**的`Promise`实例，可以链式运算

`Promise.prototype.catch()`：指定*发生错误时*的回调函数。

- 方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，但不要在`then()`中定义`Reject`状态回调函数，应使用`catch()`，因为更接近同步(`try catch`)写法
- `promise`抛出一个错误，就被`catch()`方法指定的回调函数捕获
  - 异步操作抛出错误，状态就会变为`rejected`，就会调用`catch()`处理这个错误
  - `then()`回调函数，如果运行中抛出错误，也被`catch()`方法捕获
- **状态改变后，抛出错误无效**

*Promise 对象的错误会一直向后传递，直到被捕获为止*（错误总是会被下一个`catch`语句捕获）

```js
getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
```

跟传统的`try/catch`代码块不同的是，如果没有使用`catch()`方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应，*“Promise 会吃掉错误”*

```js
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  console.log('everything is great');
});

setTimeout(() => { console.log(123) }, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
```

`Promise.prototype.finally()`：指定*不管 Promise 对象最后状态*如何，都会执行的操作。

- `finally`方法的回调函数不接受任何参数，*其中操作与状态无关*
- `finally`本质上是`then`方法的特例

```js
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  => P.resolve(callback()).then(() => value),
    reason => P.resolve(callback()).then(() => { throw reason })
  );
};
```

`finally`方法总是会返回原来的值

```js
// resolve 的值是 undefined
Promise.resolve(2).then(() => {}, () => {})

// resolve 的值是 2
Promise.resolve(2).finally(() => {})

// reject 的值是 undefined
Promise.reject(3).then(() => {}, () => {})

// reject 的值是 3
Promise.reject(3).finally(() => {})
```

### Promise

#### Promise.all

`Promise.all()`：将*多个 Promise 实例*，包装成一个新的 Promise 实例。

```js
const p = Promise.all([p1, p2, p3]);
```

- 参数可以不是数组，但*必须具有 Iterator 接口*，且返回的每个成员都是 Promise 实例

只有`p1`、`p2`、`p3`状态**都变成`fulfilled`**，`p`的状态才会**变成`fulfilled`**，此时`p1`、`p2`、`p3`的**返回值组成一个数组**，传递给`p`回调函数

只要`p1`、`p2`、`p3`之中**有一个被`rejected`**，`p`的状态就**变成`rejected`**，此时**第一个被`reject`的实例**的返回值，会传递给`p`的回调函数

作为参数的 Promise 实例，*自己定义*`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法

```js
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result)
.catch(e => e);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result)
.catch(e => e);

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// ["hello", Error: 报错了]
```

如果`p2`*没有自己*的`catch`方法，就会调用`Promise.all()`的`catch`方法

```js
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result);

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// Error: 报错了
```

#### Promise.race

`Promise.race()`：将*多个 Promise 实例*，包装成一个新的 Promise 实例

```js
const p = Promise.race([p1, p2, p3]);
```

只要`p1`、`p2`、`p3`之中有一个**实例率先改变状态**，`p`的状态就跟着改变。**率先改变的 Promise 实例的返回值**，就传递给`p`的回调函数

#### Promise.allSettled

*ES2020*`Promise.allSettled()`：接受*一组 Promise 实例作为参数*，包装成一个新的 Promise 实例。**只有等到所有这些参数实例都返回结果**。

- *返回新 Promise 实例*，一旦结束，*状态总是`fulfilled`，不会变成`rejected`*

返回的参数数组。每个对象都有`status`属性，该属性的值只可能是字符串`fulfilled`或字符串`rejected`。

`fulfilled`时，对象有`value`属性，`rejected`时有`reason`属性，对应两种状态的返回值。

```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```

`Promise.all()`无法确定所有请求都结束。`Promise.allSettled()`，更容易实现。

```js
const urls = [ /* ... */ ];
const requests = urls.map(x => fetch(x));

try {
  await Promise.all(requests);
  console.log('所有请求都成功。');
} catch {
  console.log('至少一个请求失败，其他请求可能还没结束。');
}
```

#### Promise.any

*ES2021* `Promise.any()`：接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。

只要参数实例**有一个变成`fulfilled`状态**，包装实例就**会变成`fulfilled`状态**

如果**所有参数实例都变成`rejected`状态**，包装实例就会**变成`rejected`状态**

`Promise.any()`跟`Promise.race()`相似，但`Promise.any()`*不会因为某个 Promise 变成`rejected`状态而结束*

`Promise.any()`抛出的错误是一个 *AggregateError 实例*，相当于一个数组，每个成员对应一个被`rejected`的操作所抛出的错误

```js
var resolved = Promise.resolve(42);
var rejected = Promise.reject(-1);
var alsoRejected = Promise.reject(Infinity);

Promise.any([resolved, rejected, alsoRejected]).then(function (result) {
  console.log(result); // 42
});

Promise.any([rejected, alsoRejected]).catch(function (results) {
  console.log(results); // [-1, Infinity]
});
```

#### Promise.resolve

`Promise.resolve()`：将现有对象转为 Promise 对象

```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

 **参数四种情况**

*Promise 实例*：将不做任何修改、原封不动地返回这个实例

*`thenable`对象*：将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法

```js
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function (value) {
  console.log(value);  // 42
});
```

> `thenable`对象：*具有`then`方法的对象*

*参数不是具有`then()`方法的对象，或根本就不是对象*：返回一个新的 Promise 对象，状态为`resolved`

```js
const p = Promise.resolve('Hello');

p.then(function (s) {
  console.log(s)
});
// Hello
```

*不带有任何参*：直接返回一个`resolved`状态的 Promise 对象

```js
setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
```

>立即`resolve()`的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时

#### Promise.reject

`Promise.reject(reason)`：返回一个新的 `Promise` 实例，该实例的状态为`rejected`

```js
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))
p.then(null, function (s) {
  console.log(s)
});
// 出错了
```

> `Promise.reject()`方法的参数是一个字符串，后面`catch()`方法的参数`e`就是这个字符串

#### Promise.try

*不知道或者不想区分*，函数`f`是同步函数还是异步操作，*但想用 Promise 来处理*

不管`f`是否包含异步操作，都可以`then`、`catch`方法处理`f`抛出的错误。

```js
Promise.resolve().then(f)
```

上面代码，`f`是同步函数，*会在本轮事件循环末尾执行*

```js
const f = () => console.log('now');
Promise.resolve().then(f);
console.log('next');
// next
// now
```

上面代码，`f`是同步函数，但`Promise`后，异步执行

**目的**：同步代码同步执行，异步代码异步执行，具有统一`API`

*async函数写法*

```js
const f = () => console.log('now')

(async () => f())()
.then(...)
.catch(...)

console.log('next');
// now
// next
```

> `async` 会**吃掉 抛出错误**，使用`promise.catch`方法捕获

*new Promise()*

```js
const f = () => console.log('now');
(
  () => new Promise(
    resolve => resolve(f())
  )
)();
console.log('next');
// now
// next
```

*Promise.try()*

```js
try {
  database.users.get({id: userId})
  .then(...)
  .catch(...)
} catch (e) {
  // ...
}
// 替代写法
Promise.try(() => database.users.get({id: userId}))
  .then(...)
  .catch(...)
```

> `Promise.try`就是模拟`try`代码块，就像`promise.catch`模拟的是`catch`代码块

### 应用

#### 加载图片

```js
const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

#### Generator 函数与 Promise 的结合

 Generator 函数`g`之中，有一个异步操作`getFoo`，它返回的就是一个`Promise`对象。函数`run`用来处理这个`Promise`对象，并调用下一个`next`方法。

```js
function getFoo () {
  return new Promise(function (resolve, reject){
    resolve('foo');
  });
}

const g = function* () {
  try {
    const foo = yield getFoo();
    console.log(foo);
  } catch (e) {
    console.log(e);
  }
};

function run (generator) {
  const it = generator();

  function go(result) {
    if (result.done) return result.value;
    return result.value.then(function (value) {
      return go(it.next(value));
    }, function (error) {
      return go(it.throw(error));
    });
  }

  go(it.next());
}

run(g);
```

## 原型对象

对象字面量中定义原型

```js
var person = {
 	say(){
      return "hello";
 	}
};
var coder = {
  	__proto__:person,
  	coding(){
      	return "I'm coding";
  	}
};
console.log( coder.say() );
console.log( coder.coding() );
```

## 类和对象

### 类的定义

ES6提供的类为JS原型的包装

class类：包含 构造方法、实例方法、静态方法

- class中不能直接定义属性，只能定义方法，方法之间不需要逗号隔开
- class只能先定义，再使用，没有提升效果
- 静态方法通过类名调用，实例方法只能实例化后再调用

```javascript
//类的定义
class A {
	//ES6中的构造方法（类的属性，定义在构造方法中）
    constructor(name) {
        this.name = name;
        this.age = 30;
    }
    //实例方法
    say() {
        console.log('我是A中的实例方法say，我的名字是 '+this.name);
    }
  	//静态方法(静态方法与实例方法 同名互不影响)
 	static say(){
      	console.log("我是A中的静态方法say");
 	}
}

//直接调用静态方法,由于没有实例化过程，构造方法中的代码不会自动执行
A.say();

//实例化类 调用实例方法
var a = new A('Tom');
a.say();

//类也有原型对象
console.log(A.prototype);
console.log(a.__proto__)
```

### 类的继承

父类有构造函数，子类构造函数中，需要调用super() 实现父类的构造函数

```js
//类的继承
//父类A
class A {
	//ES6中的构造方法
    constructor(name) {
        this.name = name;
        this.age = 30;
    }
    //实例方法
    say() {
        console.log('我是A中的实例方法say，我的名字是 '+this.name);
    }
  	//静态方法
 	static say(){
      	console.log("我是A中的静态方法say");
 	}
}

//子类B
class B extends A {
  	//构造方法
    constructor(name) {
    	//使用函数形式的super(), 直接调用父类构造方法
      	//只要子类写了构造方法(使用了this)，就必须调用super()，且必须在使用this之前
        super(name);
    }
  	//实例方法
  	//子类方法 会覆盖父类同名方法
    say() {
      	//子类方法中，可以使用super.方法() 调用父类的非构造方法
      	//当前方法是实例方法，则调用父类的实例方法
      	//当前方法是静态方法，则调用父类的静态方法
      	//super.say(); 
        console.log('我是B中的实例方法say，我的名字是 '+this.name);
    }
  	
    static coding() {
        console.log('我是B中的静态方法coding');
    }
  	
}
//调用静态方法
B.say(); //A的静态方法
B.coding();//B自己的静态方法

//调用实例方法
var b = new B('Lucy');
b.say();//B中的实例方法say  //如果B中没有，才调用A的实例方法say
b.coding();//报错，B和A中都没有实例方法coding  （只有静态方法）
```





