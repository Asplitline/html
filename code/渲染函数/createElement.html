<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../vue.js"></script>
</head>

<body>
    <div id='app'>
    </div>
</body>
<script>
    var app = new Vue({
        el: '#app',
        data: {
        },
        // <div id="foo" class="foo" style="color: red; font-size: 14px;">baz</div>
        render(createElement) {
            return createElement(
                // 参数1：{String|Object|Funtion} -（必填） 标签名、组件选项对象、resolve上任何一种async函数
                'div',
                // 参数2：{Object} - （选填） 与模板对应的attribute数据对象
                {
                    // 与 `v-bind:class` 的 API 相同，
                    // 接受一个字符串、对象或字符串和对象组成的数组
                    'class': {
                        foo: true,
                        bar: false
                    },
                    // 与 `v-bind:style` 的 API 相同，
                    // 接受一个字符串、对象，或对象组成的数组
                    style: {
                        color: 'red',
                        fontSize: '14px'
                    },
                    // 普通的 HTML attribute
                    attrs: {
                        id: 'foo'
                    },
                    // 组件 prop
                    props: {
                        myProp: 'bar'
                    },
                    // DOM property
                    domProps: {
                        innerHTML: 'baz'
                    },
                    // 事件监听器在 `on` 内，
                    // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。
                    // 需要在处理函数中手动检查 keyCode。
                    on: {
                        click: this.clickHandler
                    },
                    // 仅用于组件，用于监听原生事件，而不是组件内部使用
                    // `vm.$emit` 触发的事件。
                    nativeOn: {
                        click: this.nativeClickHandler
                    },
                    // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`
                    // 赋值，因为 Vue 已经自动为你进行了同步。
                    directives: [
                        {
                            name: 'my-custom-directive',
                            value: '2',
                            expression: '1 + 1',
                            arg: 'foo',
                            modifiers: {
                                bar: true
                            }
                        }
                    ],
                    // 作用域插槽的格式为
                    // { name: props => VNode | Array<VNode> }
                    scopedSlots: {
                        default: props => createElement('span', props.text)
                    },
                    // 如果组件是其它组件的子组件，需为插槽指定名称
                    slot: 'name-of-slot',
                    // 其它特殊顶层 property
                    key: 'myKey',
                    ref: 'myRef',
                    // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，
                    // 那么 `$refs.myRef` 会变成一个数组。
                    refInFor: true
                },
                // 参数3：{String|Array} 子级虚拟节点，有createElement()构建
                [
                    '测试', //文本虚拟节点 - （可选）
                    createElement('h1', '标题'),
                ]

            );
        }
    })
</script>

</html>