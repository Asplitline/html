# 你应该知道的 NPM 知识都在这！

https://mp.weixin.qq.com/s/sRhuMQ3f6vjUkabUy_dEYQ

## npm init

### 自定义 npm init 行为

任意目录下，创建一个 `.npm-init.js`

- module.exports 内容：即为 package.json 配置内容
- prompt() ：获取用户输入。

例如编写这样的 ~/.npm-init.js

```shell
const desc = prompt('description?', 'A new package...')
const bar = prompt('bar?', '')
const count = prompt('count?', '42')

module.exports = {
  key: 'value',
  foo: {
    bar: bar,
    count: count
  },
  name: prompt('name?', process.cwd().split('/').pop()),
  version: prompt('version?', '0.1.0'),
  description: desc,
  main: 'index.js',
}

```

## package.json 中的常规属性

### dependenices

生产依赖项

```shell
npm install/i packageName -S/--save
```

> 未指定版本，默认为最新版本

指定版本：`npm i vue@3.0.1 -S`

如果要指定版本的，可以把版本号写在包名后面，比如

### devDependenices

开发依赖项：只在开发环境使用 

```shell
npm install/i packageName -D/--save-dev
```

- 本地（开发环境）：开发依赖正常安装
- 用户（生产环境）：开发以来忽略

### bin

bin：指定各个内部命令对应的**可执行文件的位置**

- 全局安装：把可执行文件链接到 `/usr/local/bin`
- 项目安装：把可执行文件链接到 `./node_modules/.bin/`

```shell
 "bin": {
    "vm2": "./bin/vm2"
  },
```

例子：npm 在 /usr/local/bin 创建一个为 vm2 软链接，指向全局安装下来的 vm2 包下面的 "./bin/index.js"。

### script 

#### npm script 脚本

```js
"scripts": {
    "test": "test.js"
    "build": "tsc",
  },
```

scripts 对象中每一个属性，对应一段脚本。比如，test 命令对应的脚本是 node test.js
命令行下使用 npm run 命令，就可以执行这段脚本。
查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令
原理
我们每次在运行 scripts 中的一个属性时候(npm run),**实际系统都会自动新建一个shell(一般是Bash)，在这个shell里面执行指定的脚本命令。因此 凡是能在 shell 中允许的脚本，都可以写在npm scripts中。
特别的点，npm run 新建的 shell，会在当前目录的 node_modules/.bin 子目录加入到 PATH 变量，执行结束后，再将 PATH 变量恢复原样。也就是说，当前项目目录 node——modules/.bin 子目录中所有的脚本，都可以直接用脚本名称调用，不需要增加路径.（简单总结：通过 npm 启动的脚本，会默认把 node_modules/.bin 加到 PATH 环境变量中。）
"test": "mocha test
"test": "./node_modules/.bin/mocha test"
node_modules目录下的.bin文件是哪里来的?
npm install 安装的某个模块，如果模块在 package.json 中配置了 bin 属性，在安装时候会自动软链接到 node_modules/.bin 中
如 mocha 源码 配置
{
    "name":"mocha",
    "bin":{
        "mocha":"./bin/mocha"
    }
}

 npm 本身对两个脚本提供了默认值，这两个脚本不用在 script 属性中定义，可以直接使用
"start": "node server.js"
"install": "node-gyp rebuild"
前提是根目录下有这两个文件
node-gyp：node 下的 gyp。npm 为了方便直接源码分发，用户装的时候需要自己进下编译，我们在开发 node 程序中需要调用一些其他语言编写的工具甚至 dll，这时候需要先编译下其他语言，否则会出现跨平台的问题。node-gyp 是用来编译原生 C++ 模块的，也可以编写自己写的 C++文件，node-gyp 在较新的 Node 版本中都是自带的，而且是最先版本。
gyp 文件：当 Node.js 项目中有需要和 C++ 交互的需求时，项目的根目需要创建 binging.gyp 文件，每个.gyp 文件都描述了如何去构建项目，每个.gyp文件都描述了如何去构建项目，gyp文件的语法是 Python数据格式(Json格式)，配置中数据是键-值对的形式
钩子(生命周期)
npm 脚本有两个钩子，pre 和 post，当我们执行start脚本时候，start 的钩子就是 prestart 和 poststart。
执行 npm run start 的时候，npm 会自动按照下面的顺序执行
npm run prestart && npm run start && npm run poststart
可以做一些准备或者清理工作
不可乱用
prestart 里面设置了一个环境变量，但是在项目 start 的时候，无法拿到设置的环境变量，因为 script 的属性运行的时候都会新启动一个 shell，所以在 prestart中设置的环境变量只对应了那个shell的运行时
env 环境变量
我们在执行 npm run 脚本时候, npm 会设置一些特殊的env环境变量。其中package.json中的所有字段，都会被设置为以npm_package_开头的环境变量。
{
  "name": "npm-demo",
  "version": "1.0.0",
  "script": {
    "build": "webpack --mode=production"
  },
  "files": ["src"]
}
可以得到 npm_package_name、npm_package_version、npm_package_script_build、npm_package_files_0等变量。注意上面 package.json 中对象和数组中每个字段都会有对应的环境变量。
同时，npm 相关的所有配置也会被设置为以npm_config_开头的环境变量。此外，还会设置一个比较特殊的环境变量npm_lifecycle_event，表示正在运行的脚本名称。比如执行npm run serve 的时候，process.env.npm_lifecycle_event值为serve，通过判断这个变量，可以将一个脚本使用在不同的npm scripts中。这里还要提一下上面说的钩子，npm_lifecycle_event可以和钩子配合使用，利用这个变量，在同一个脚本文件里面，为不同的 npm scripts 命令编写代
const TARGET = process.env.npm_lifecycle_event;

if (TARGET === 'service') {
  console.log(`Running the service task!`);
}

if (TARGET === 'preservice') {
  console.log(`Running the preservice task!`);
}

if (TARGET === 'postservice') {
  console.log(`Running the postservice task!`);
}
强调：这些环境变量只能在 npm run 的脚本执行环境内拿到，正常执行的 node 脚本是获取不到的。
不能直接通过 env $npm_package_name 的形式访问，但可以在 scripts 中定义脚本"scripts": {"bundle": "echo $npm_package_name"}来访问
列出所有环境变量
npm run env
shell脚本中输出环境变量
echo PATH
shell 脚本设置环境变量
echo PATH = /usr/local/lib
shell脚本中设置环境变量时候如何拼接相对路径
null
echo PATH = ${pwd}/lib/include  //使用${},也可以直接使用双引号
脚本传入参数
node 处理 scripts 中的参数，除了属性后面的第一个命令，以空格分割的任何字符串(除特别shell语法)都是参数，并且都能通过 process.argv 属性访问。
process.argv 属性返回一个数组，数组包含了启动 node 进程时的命令行参数。第一个元素为启动 node 进程的可执行文件的绝对路径名 process.execPath,第二个元素为当前执行的 jacascript 文件路径。剩余的元素为其他命令行参数。
script 例子
"scripts":{
  "serve": "vue-cli-service serve --mode=dev --mobile -config build/example.js"
}
npm run server 命令的时候，process.argv 的具体内容为
[ '/usr/local/Cellar/node/12.14.1/bin/node',
  '/Users/mac/Vue-projects/hao-cli/node_modules/.bin/vue-cli-service',
  'serve',
  '--mode=dev',
  '--mobile',
  '-config',
  'build/example.js']
传参可能有的方式
null
npm run serve --params  // 参数params将转化成process.env.npm_config_params = true
npm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123
npm run serve -params  // 等同于--params参数

npm run serve -- --params  // 将--params参数添加到process.env.argv数组中
npm run serve params  // 将params参数添加到process.env.argv数组中
npm run serve -- params  // 将params参数添加到process.env.argv数组中
npm install koa2 --save 是不是知道了bin脚本中接收到的 process.env.npm_config_save = true;
